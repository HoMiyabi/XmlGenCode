// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "PuertsValueType.h"
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

namespace puerts
{


// Unity.Mathematics.uint3 mad(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv2);
    S_u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, struct S_u4u4u4_ p2, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 select(Unity.Mathematics.uint3, Unity.Mathematics.uint3, Boolean) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_S_u4u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_S_u4u4u4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, bool p2, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 shuffle(Unity.Mathematics.uint3, Unity.Mathematics.uint3, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_S_u4u4u4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_S_u4u4u4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 rol(Unity.Mathematics.uint3, Int32) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, int32_t p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 op_Multiply(Unity.Mathematics.uint3, UInt32) declare in Unity.Mathematics.uint3
bool w_S_u4u4u4_S_u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, uint32_t p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 mul(Unity.Mathematics.uint4, Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 shuffle(Unity.Mathematics.uint4, Unity.Mathematics.uint4, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4u4_S_u4u4u4u4_S_u4u4u4u4_u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_S_u4u4u4u4_S_u4u4u4u4_u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef struct S_u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(Boolean) declare in Unity.Mathematics.math
bool w_S_u4u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4_ (*FuncToCall)(bool p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(Int32) declare in Unity.Mathematics.math
bool w_S_u4u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(Single) declare in Unity.Mathematics.math
bool w_S_u4u4u4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4_ (*FuncToCall)(float p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(Double) declare in Unity.Mathematics.math
bool w_S_u4u4u4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4_ (*FuncToCall)(double p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 NextUInt3() declare in Unity.Mathematics.Random
bool w_S_u4u4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 NextUInt3(Unity.Mathematics.uint3) declare in Unity.Mathematics.Random
bool w_S_u4u4u4_tS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_tS_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(void*,struct S_u4u4u4_ p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 NextUInt3(Unity.Mathematics.uint3, Unity.Mathematics.uint3) declare in Unity.Mathematics.Random
bool w_S_u4u4u4_tS_u4u4u4_S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_tS_u4u4u4_S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(void*,struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(UInt32, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4u4_u4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_u4S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(uint32_t p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 op_Multiply(UInt32, Unity.Mathematics.uint3) declare in Unity.Mathematics.uint3
bool w_S_u4u4u4_u4S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_u4S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4u4_ (*FuncToCall)(uint32_t p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint3 uint3(UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4_u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4_u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u4u4u4_ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, const void* method);
    struct S_u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.GUID Generate() declare in UnityEditor.GUID
bool w_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4u4_ (*FuncToCall)(const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.RigidTransform) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_S_r4r4r4r4__S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_S_r4r4r4r4__S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4__S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4__S_r4r4r4__>(apis, env, _sv0);
    S_S_S_r4r4r4r4__S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4__S_r4r4r4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_S_r4r4r4r4__S_r4r4r4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.bool4x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.bool4x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_bbbb_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_bbbb_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb_S_bbbb__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_bbbb_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.bool4x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_bbbb_S_bbbb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_bbbb_S_bbbb__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_bbbb_S_bbbb__* pp0 = DataTransfer::GetPointer<S_S_bbbb_S_bbbb__>(apis, env, _sv0);
    S_S_bbbb_S_bbbb__ p0 = pp0 ? *pp0 : S_S_bbbb_S_bbbb__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_bbbb_S_bbbb__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.int4x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.int4x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.int4x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_i4i4i4i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_i4i4i4i4_S_i4i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4i4_S_i4i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4i4_S_i4i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4i4_S_i4i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4i4_S_i4i4i4i4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_i4i4i4i4_S_i4i4i4i4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.float4x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.float4x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.float4x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.quaternion) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r4r4r4r4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.double4x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.double4x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.double4x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_r8r8r8r8_S_r8r8r8r8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_r8r8r8r8_S_r8r8r8r8__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r8r8r8r8_S_r8r8r8r8__* pp0 = DataTransfer::GetPointer<S_S_r8r8r8r8_S_r8r8r8r8__>(apis, env, _sv0);
    S_S_r8r8r8r8_S_r8r8r8r8__ p0 = pp0 ? *pp0 : S_S_r8r8r8r8_S_r8r8r8r8__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_r8r8r8r8_S_r8r8r8r8__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.half4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u2_S_u2_S_u2_S_u2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u2_S_u2_S_u2_S_u2__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u2_S_u2_S_u2_S_u2__* pp0 = DataTransfer::GetPointer<S_S_u2_S_u2_S_u2_S_u2__>(apis, env, _sv0);
    S_S_u2_S_u2_S_u2_S_u2__ p0 = pp0 ? *pp0 : S_S_u2_S_u2_S_u2_S_u2__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u2_S_u2_S_u2_S_u2__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mul(Unity.Mathematics.uint4x4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.uint4x3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mul(Unity.Mathematics.uint4x3, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.uint4x2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mul(Unity.Mathematics.uint4x2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4__S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4__S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4__* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv0);
    S_S_u4u4u4u4_S_u4u4u4u4__ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_S_u4u4u4u4__ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_S_u4u4u4u4_S_u4u4u4u4__ p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.float4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 hashwide(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_r8r8r8r8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mul(Unity.Mathematics.uint2, Unity.Mathematics.uint2x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4_S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__>(apis, env, _sv1);
    S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_S_u4u4_S_u4u4_S_u4u4_S_u4u4__ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Unity.Mathematics.uint2, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4_S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 shuffle(Unity.Mathematics.uint2, Unity.Mathematics.uint2, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4_S_u4u4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4_S_u4u4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Unity.Mathematics.uint2, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4_u4u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4_ p0, uint32_t p1, uint32_t p2, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mul(Unity.Mathematics.uint3, Unity.Mathematics.uint3x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4_S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_S_u4u4u4_S_u4u4u4_S_u4u4u4_S_u4u4u4__ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 shuffle(Unity.Mathematics.uint3, Unity.Mathematics.uint3, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4_S_u4u4u4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4_S_u4u4u4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, struct S_u4u4u4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Unity.Mathematics.uint3, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4_ p0, uint32_t p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 reversebits(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mul(Unity.Mathematics.uint4, Unity.Mathematics.uint4x4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__>(apis, env, _sv1);
    S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 min(Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 select(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_bbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_bbbb_* pp2 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv2);
    S_bbbb_ p2 = pp2 ? *pp2 : S_bbbb_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, struct S_bbbb_ p2, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 mad(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv2);
    S_u4u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, struct S_u4u4u4u4_ p2, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 select(Unity.Mathematics.uint4, Unity.Mathematics.uint4, Boolean) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, bool p2, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 shuffle(Unity.Mathematics.uint4, Unity.Mathematics.uint4, ShuffleComponent, ShuffleComponent, ShuffleComponent, ShuffleComponent) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_u1u1u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_u1u1u1u1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(apis, env, _sv5);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, uint8_t p2, uint8_t p3, uint8_t p4, uint8_t p5, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 rol(Unity.Mathematics.uint4, Int32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_S_u4u4u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, int32_t p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 op_Multiply(Unity.Mathematics.uint4, UInt32) declare in Unity.Mathematics.uint4
bool w_S_u4u4u4u4_S_u4u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_S_u4u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(struct S_u4u4u4u4_ p0, uint32_t p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Boolean) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(bool p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Int32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Single) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(float p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(Double) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(double p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.GUID GUIDFromAssetPath(System.String) declare in UnityEditor.AssetDatabase
bool w_S_u4u4u4u4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.GUID get_guid() declare in UnityEditor.EditorBuildSettingsScene
bool w_S_u4u4u4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 NextUInt4(Unity.Mathematics.uint4) declare in Unity.Mathematics.Random
bool w_S_u4u4u4u4_tS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_tS_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 NextUInt4(Unity.Mathematics.uint4, Unity.Mathematics.uint4) declare in Unity.Mathematics.Random
bool w_S_u4u4u4u4_tS_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_tS_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(void*,struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(UInt32, Unity.Mathematics.uint2, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_u4S_u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_u4S_u4u4_u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(uint32_t p0, struct S_u4u4_ p1, uint32_t p2, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(UInt32, Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_u4S_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_u4S_u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv1);
    S_u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(uint32_t p0, struct S_u4u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 op_Multiply(UInt32, Unity.Mathematics.uint4) declare in Unity.Mathematics.uint4
bool w_S_u4u4u4u4_u4S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_u4S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(uint32_t p0, struct S_u4u4u4u4_ p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(UInt32, UInt32, Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_u4u4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_u4u4S_u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};

    typedef struct S_u4u4u4u4_ (*FuncToCall)(uint32_t p0, uint32_t p1, struct S_u4u4_ p2, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Mathematics.uint4 uint4(UInt32, UInt32, UInt32, UInt32) declare in Unity.Mathematics.math
bool w_S_u4u4u4u4_u4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_u4u4u4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef struct S_u4u4u4u4_ (*FuncToCall)(uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.NVIDIA.DLSSCommandInitializationData get_initData() declare in UnityEngine.NVIDIA.DLSSDebugFeatureInfos
bool w_S_u4u4u4u4i4i4u4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4i4i4u4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4u4i4i4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4i4i4u4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.BuildUsageTagGlobal GetGlobalUsageFromGraphicsSettings() declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_u4u4u4u4u4bbbbbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.BuildUsageTagGlobal op_BitwiseOr(UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagGlobal) declare in UnityEditor.Build.Content.BuildUsageTagGlobal
bool w_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv0);
    S_u4u4u4u4u4bbbbbbb_ p0 = pp0 ? *pp0 : S_u4u4u4u4u4bbbbbbb_ {};
    // JSValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(apis, env, _sv1);
    S_u4u4u4u4u4bbbbbbb_ p1 = pp1 ? *pp1 : S_u4u4u4u4u4bbbbbbb_ {};

    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(struct S_u4u4u4u4u4bbbbbbb_ p0, struct S_u4u4u4u4u4bbbbbbb_ p1, const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.BuildUsageTagGlobal GetGlobalUsageFromActiveScene(UnityEditor.BuildTarget) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_u4u4u4u4u4bbbbbbb_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Build.Content.BuildUsageTagGlobal get_globalUsage() declare in UnityEditor.Build.Content.SceneDependencyInfo
bool w_S_u4u4u4u4u4bbbbbbb_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(UnityEngine.Hash128) declare in UnityEditor.Search.PropertyDatabase
bool w_S_u8S_u8u8__S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};

    typedef struct S_u8S_u8u8__ (*FuncToCall)(struct S_u8u8_ p0, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(System.String) declare in UnityEditor.Search.PropertyDatabase
bool w_S_u8S_u8u8__s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u8S_u8u8__ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(System.String, UnityEngine.Hash128) declare in UnityEditor.Search.PropertyDatabase
bool w_S_u8S_u8u8__sS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__sS_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};

    typedef struct S_u8S_u8u8__ (*FuncToCall)(Il2CppString* p0, struct S_u8u8_ p1, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(System.String, System.String) declare in UnityEditor.Search.PropertyDatabase
bool w_S_u8S_u8u8__ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_u8S_u8u8__ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(UInt64, UnityEngine.Hash128) declare in UnityEditor.Search.PropertyDatabase
bool w_S_u8S_u8u8__u8S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__u8S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};

    typedef struct S_u8S_u8u8__ (*FuncToCall)(uint64_t p0, struct S_u8u8_ p1, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime get_Now() declare in System.DateTime
bool w_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8_ (*FuncToCall)(const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.Object) declare in System.Convert
bool w_S_u8_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_O");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.Object, System.IFormatProvider) declare in System.Convert
bool w_S_u8_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_Oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_S_S_p_i4_DoDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_DoDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_S_S_p_i4_S_S_p_i4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_S_S_p_i4_oDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_S_S_p_i4_ooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_ooDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime op_Explicit(System.Data.SqlTypes.SqlDateTime) declare in System.Data.SqlTypes.SqlDateTime
bool w_S_u8_S_bi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_bi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bi4i4_* pp0 = DataTransfer::GetPointer<S_bi4i4_>(apis, env, _sv0);
    S_bi4i4_ p0 = pp0 ? *pp0 : S_bi4i4_ {};

    typedef struct S_u8_ (*FuncToCall)(struct S_bi4i4_ p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.Decimal) declare in System.Convert
bool w_S_u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef struct S_u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.ProfilerRecorder StartNew(Unity.Profiling.ProfilerMarker, Int32, Unity.Profiling.ProfilerRecorderOptions) declare in Unity.Profiling.ProfilerRecorder
bool w_S_u8_S_p_Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_p_Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_p_ p0, int32_t p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Profiling.ProfilerRecorder StartNew(Unity.Profiling.ProfilerCategory, System.String, Int32, Unity.Profiling.ProfilerRecorderOptions) declare in Unity.Profiling.ProfilerRecorder
bool w_S_u8_S_u2_sDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u2_sDi4Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_u2_ p0, Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ConvertTimeToUtc(System.DateTime) declare in System.TimeZoneInfo
bool w_S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime op_Addition(System.DateTime, System.TimeSpan) declare in System.DateTime
bool w_S_u8_S_u8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_S_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, struct S_i8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray64 op_BitwiseOr(UnityEngine.Rendering.BitArray64, UnityEngine.Rendering.BitArray64) declare in UnityEngine.Rendering.BitArray64
bool w_S_u8_S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, struct S_u8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime SpecifyKind(System.DateTime, System.DateTimeKind) declare in System.DateTime
bool w_S_u8_S_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ConvertTime(System.DateTime, System.TimeZoneInfo) declare in System.TimeZoneInfo
bool w_S_u8_S_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ConvertTime(System.DateTime, System.TimeZoneInfo, System.TimeZoneInfo) declare in System.TimeZoneInfo
bool w_S_u8_S_u8_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime, System.String) declare in System.TimeZoneInfo
bool w_S_u8_S_u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, Il2CppString* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Loading.ContentFile LoadContentFileAsync(Unity.Content.ContentNamespace, System.String, Unity.Collections.NativeArray`1[Unity.Loading.ContentFile], Unity.Jobs.JobHandle) declare in Unity.Loading.ContentLoadInterface
bool w_S_u8_S_u8_sS_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_sS_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal valuetype  with default
    S_u8i4i4p_ p3 = OptionalParameter<S_u8i4i4p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, Il2CppString* p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_u8i4i4p_ p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime, System.String, System.String) declare in System.TimeZoneInfo
bool w_S_u8_S_u8_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Loading.ContentSceneFile LoadSceneAsync(Unity.Content.ContentNamespace, System.String, System.String, Unity.Loading.ContentSceneParameters, Unity.Collections.NativeArray`1[Unity.Loading.ContentFile], Unity.Jobs.JobHandle) declare in Unity.Loading.ContentLoadInterface
bool w_S_u8_S_u8_ssS_i4i4b_S_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_ssS_i4i4b_S_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i4i4b_* pp3 = DataTransfer::GetPointer<S_i4i4b_>(apis, env, _sv3);
    S_i4i4b_ p3 = pp3 ? *pp3 : S_i4i4b_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp4 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv4);
    S_Pvi4i4i4S_pi4i4_i4_ p4 = pp4 ? *pp4 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal valuetype  with default
    S_u8i4i4p_ p5 = OptionalParameter<S_u8i4i4p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 5);
                

    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p0, Il2CppString* p1, Il2CppString* p2, struct S_i4i4b_ p3, struct S_Pvi4i4i4S_pi4i4_i4_ p4, struct S_u8i4i4p_ p5, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Boolean) declare in System.Convert
bool w_S_u8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_b");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(bool p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Char) declare in System.Convert
bool w_S_u8_c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_c");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(Il2CppChar p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(SByte) declare in System.Convert
bool w_S_u8_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(int8_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int16) declare in System.Convert
bool w_S_u8_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(int16_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int32) declare in System.Convert
bool w_S_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime Calculate(Codice.Client.BaseCommands.LayoutFilters.SinceTimeType, System.DateTime, System.DateTime) declare in Codice.Client.BaseCommands.LayoutFilters.CalculateSinceTime
bool w_S_u8_i4S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i4S_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};

    typedef struct S_u8_ (*FuncToCall)(int32_t p0, struct S_u8_ p1, struct S_u8_ p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int32, Int32, System.DayOfWeek) declare in System.Globalization.ISOWeek
bool w_S_u8_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u8_ (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int64) declare in System.Convert
bool w_S_u8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(int64_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int64, Int64) declare in Mono.Unix.Native.NativeConvert
bool w_S_u8_i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(int64_t p0, int64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Mono.Security.ASN1) declare in Mono.Security.ASN1Convert
bool w_S_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Single) declare in System.Convert
bool w_S_u8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(float p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Double) declare in System.Convert
bool w_S_u8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_r8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(double p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.String) declare in System.Convert
bool w_S_u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.String, System.Xml.XmlDateTimeSerializationMode) declare in System.Xml.XmlConvert
bool w_S_u8_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_si4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.String, System.IFormatProvider) declare in System.Convert
bool w_S_u8_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime AdjustFile(System.String, Codice.CM.Common.RevisionInfo, Boolean, Int32, Boolean) declare in Codice.Client.BaseCommands.BaseServices
bool w_S_u8_sobi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sobi4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, bool p2, int32_t p3, bool p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime Parse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_soi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_sooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.String, System.String) declare in System.Xml.XmlConvert
bool w_S_u8_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider) declare in System.DateTime
bool w_S_u8_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_ssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ssoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime get_Date() declare in System.DateTime
bool w_S_u8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8_ (*FuncToCall)(void*,const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(System.Object) declare in System.Runtime.Serialization.FormatterConverter
bool w_S_u8_tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime Add(System.TimeSpan) declare in System.DateTime
bool w_S_u8_tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};

    typedef struct S_u8_ (*FuncToCall)(void*,struct S_i8_ p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToUniversalTime(System.DateTime) declare in System.TimeZone
bool w_S_u8_tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef struct S_u8_ (*FuncToCall)(void*,struct S_u8_ p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime AddMonths(System.DateTime, Int32) declare in System.Globalization.PersianCalendar
bool w_S_u8_tS_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(void*,struct S_u8_ p0, int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime AddMilliseconds(System.DateTime, Double) declare in System.Globalization.Calendar
bool w_S_u8_tS_u8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_u8_r8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(void*,struct S_u8_ p0, double p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime AddMonths(Int32) declare in System.DateTime
bool w_S_u8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in System.Globalization.Calendar
bool w_S_u8_ti4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) declare in System.Globalization.PersianCalendar
bool w_S_u8_ti4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime AddTicks(Int64) declare in System.DateTime
bool w_S_u8_ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime AddDays(Double) declare in System.DateTime
bool w_S_u8_tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tr8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(void*,double p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime GetDateTime(System.String) declare in System.Runtime.Serialization.SerializationInfo
bool w_S_u8_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime GetDateTime(System.String, Int64) declare in Codice.Utils.ConfigurationSection
bool w_S_u8_tsi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tsi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppString* p0, int64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ReadElementContentAsDateTime(System.String, System.String) declare in System.Xml.XmlReader
bool w_S_u8_tss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppString* p0, Il2CppString* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(Byte) declare in System.Convert
bool w_S_u8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u1");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(uint8_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(UInt16) declare in System.Convert
bool w_S_u8_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u2");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(uint16_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(UInt32) declare in System.Convert
bool w_S_u8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(uint32_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// System.DateTime ToDateTime(UInt64) declare in System.Convert
bool w_S_u8_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8_ (*FuncToCall)(uint64_t p0, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.XR.InputDevice GetDeviceAtXRNode(UnityEngine.XR.XRNode) declare in UnityEngine.XR.InputDevices
bool w_S_u8b_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8b_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8b_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u8b_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.DisplayInfo get_mainWindowDisplayInfo() declare in UnityEngine.Screen
bool w_S_u8i4i4S_u4u4_S_i4i4i4i4_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4S_u4u4_S_i4i4i4i4_s_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ (*FuncToCall)(const void* method);
    struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle Schedule(JobScheduleParameters ByRef) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p0 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u8i4i4p_i4pp_));
        p0 = &up0;
    }
        

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_S_u8i4i4p_i4pp_* p0, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle ScheduleParallelForDeferArraySize(JobScheduleParameters ByRef, Int32, Void*, Void*) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4PvPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4PvPv");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p0 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u8i4i4p_i4pp_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_S_u8i4i4p_i4pp_* p0, int32_t p1, void* p2, void* p3, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle ScheduleParallelFor(JobScheduleParameters ByRef, Int32, Int32) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p0 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u8i4i4p_i4pp_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_S_u8i4i4p_i4pp_* p0, int32_t p1, int32_t p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle ScheduleParallelForTransform(JobScheduleParameters ByRef, IntPtr) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_p");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p0 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u8i4i4p_i4pp_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_S_u8i4i4p_i4pp_* p0, void* p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle ScheduleParallelForTransformReadOnly(JobScheduleParameters ByRef, IntPtr, Int32) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p0 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u8i4i4p_i4pp_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_S_u8i4i4p_i4pp_* p0, void* p1, int32_t p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle CombineDependencies(Unity.Jobs.JobHandle*, Int32) declare in Unity.Jobs.LowLevel.Unsafe.JobHandleUnsafeUtility
bool w_S_u8i4i4p_Pvi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_Pvi4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p0, int32_t p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle CombineDependencies(Unity.Collections.NativeArray`1[Unity.Jobs.JobHandle]) declare in Unity.Jobs.JobHandle
bool w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle ScheduleBatch(Unity.Collections.NativeArray`1[UnityEngine.RaycastCommand], Unity.Collections.NativeArray`1[UnityEngine.RaycastHit], Int32, Unity.Jobs.JobHandle) declare in UnityEngine.RaycastCommand
bool w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4DS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal valuetype  with default
    S_u8i4i4p_ p3 = OptionalParameter<S_u8i4i4p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, struct S_u8i4i4p_ p3, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle ScheduleBatch(Unity.Collections.NativeArray`1[UnityEngine.RaycastCommand], Unity.Collections.NativeArray`1[UnityEngine.RaycastHit], Int32, Int32, Unity.Jobs.JobHandle) declare in UnityEngine.RaycastCommand
bool w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4i4DS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4i4DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal valuetype  with default
    S_u8i4i4p_ p4 = OptionalParameter<S_u8i4i4p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 4);
                

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, int32_t p3, struct S_u8i4i4p_ p4, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle CombineDependencies(Unity.Collections.NativeSlice`1[Unity.Jobs.JobHandle]) declare in Unity.Jobs.JobHandle
bool w_S_u8i4i4p_S_Pvi4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4i4S_pi4i4__");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pvi4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pvi4i4i4i4S_pi4i4__ {};

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4i4S_pi4i4__ p0, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle GetWriter(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_S_u8i4i4p_S_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_pi4i4_ p0, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle CombineDependencies(Unity.Jobs.JobHandle, Unity.Jobs.JobHandle) declare in Unity.Jobs.JobHandle
bool w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8i4i4p_* pp0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv0);
    S_u8i4i4p_ p0 = pp0 ? *pp0 : S_u8i4i4p_ {};
    // JSValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_u8i4i4p_ p0, struct S_u8i4i4p_ p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle CombineDependencies(Unity.Jobs.JobHandle, Unity.Jobs.JobHandle, Unity.Jobs.JobHandle) declare in Unity.Jobs.JobHandle
bool w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8i4i4p_* pp0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv0);
    S_u8i4i4p_ p0 = pp0 ? *pp0 : S_u8i4i4p_ {};
    // JSValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};
    // JSValToCSVal struct
    S_u8i4i4p_* pp2 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv2);
    S_u8i4i4p_ p2 = pp2 ? *pp2 : S_u8i4i4p_ {};

    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_u8i4i4p_ p0, struct S_u8i4i4p_ p1, struct S_u8i4i4p_ p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle CloseCachedFileAsync(System.String, Unity.Jobs.JobHandle) declare in Unity.IO.LowLevel.Unsafe.AsyncReadManager
bool w_S_u8i4i4p_sDS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_sDS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    S_u8i4i4p_ p1 = OptionalParameter<S_u8i4i4p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_u8i4i4p_ (*FuncToCall)(Il2CppString* p0, struct S_u8i4i4p_ p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle get_JobHandle() declare in Unity.IO.LowLevel.Unsafe.FileHandle
bool w_S_u8i4i4p_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8i4i4p_ (*FuncToCall)(void*,const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle Close(Unity.Jobs.JobHandle) declare in Unity.IO.LowLevel.Unsafe.FileHandle
bool w_S_u8i4i4p_tDS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_tDS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_u8i4i4p_ p0 = OptionalParameter<S_u8i4i4p_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef struct S_u8i4i4p_ (*FuncToCall)(void*,struct S_u8i4i4p_ p0, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Unity.Jobs.JobHandle Dispose(Unity.Jobs.JobHandle) declare in UnityEngine.LightProbesQuery
bool w_S_u8i4i4p_tS_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_tS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8i4i4p_* pp0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv0);
    S_u8i4i4p_ p0 = pp0 ? *pp0 : S_u8i4i4p_ {};

    typedef struct S_u8i4i4p_ (*FuncToCall)(void*,struct S_u8i4i4p_ p0, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.XR.MeshId get_InvalidId() declare in UnityEngine.XR.MeshId
bool w_S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8u8_ (*FuncToCall)(const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 Compute(Void*, UInt64) declare in UnityEngine.Hash128
bool w_S_u8u8_Pvu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_Pvu8");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef struct S_u8u8_ (*FuncToCall)(void* p0, uint64_t p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 GetAssetDependencyHash(UnityEditor.GUID) declare in UnityEditor.AssetDatabase
bool w_S_u8u8_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef struct S_u8u8_ (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray128 op_OnesComplement(UnityEngine.Rendering.BitArray128) declare in UnityEngine.Rendering.BitArray128
bool w_S_u8u8_S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};

    typedef struct S_u8u8_ (*FuncToCall)(struct S_u8u8_ p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray128 op_BitwiseOr(UnityEngine.Rendering.BitArray128, UnityEngine.Rendering.BitArray128) declare in UnityEngine.Rendering.BitArray128
bool w_S_u8u8_S_u8u8_S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_S_u8u8_S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};

    typedef struct S_u8u8_ (*FuncToCall)(struct S_u8u8_ p0, struct S_u8u8_ p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 Compute(Int32) declare in UnityEngine.Hash128
bool w_S_u8u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef struct S_u8u8_ (*FuncToCall)(int32_t p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Unix.Native.In6Addr ToIn6Addr(System.Net.IPAddress) declare in Mono.Unix.Native.NativeConvert
bool w_S_u8u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef struct S_u8u8_ (*FuncToCall)(Il2CppObject* p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 CalculatePlayerSerializationHashForType(System.Type, UnityEditor.Build.Player.TypeDB) declare in UnityEditor.Build.Content.ContentBuildInterface
bool w_S_u8u8_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef struct S_u8u8_ (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 Compute(Single) declare in UnityEngine.Hash128
bool w_S_u8u8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef struct S_u8u8_ (*FuncToCall)(float p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 Parse(System.String) declare in UnityEngine.Hash128
bool w_S_u8u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u8u8_ (*FuncToCall)(Il2CppString* p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 GetArtifactHash(System.String, ImportSyncMode) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_u8u8_sDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_sDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef struct S_u8u8_ (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 GetArtifactHash(System.String, System.Type, ImportSyncMode) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_S_u8u8_soDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_soDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef struct S_u8u8_ (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 get_hash() declare in UnityEngine.CachedAssetBundle
bool w_S_u8u8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8u8_ (*FuncToCall)(void*,const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext) declare in UnityEngine.UIElements.UxmlHash128AttributeDescription
bool w_S_u8u8_toS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_toS_oooo_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef struct S_u8u8_ (*FuncToCall)(void*,Il2CppObject* p0, struct S_oooo_ p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Hash128 GetAssetBundleHash(System.String) declare in UnityEngine.AssetBundleManifest
bool w_S_u8u8_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef struct S_u8u8_ (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Mono.Unix.Native.Stat ToStat() declare in Mono.Unix.UnixFileSystemInfo
bool w_S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ (*FuncToCall)(void*,const void* method);
    struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray256 op_OnesComplement(UnityEngine.Rendering.BitArray256) declare in UnityEngine.Rendering.BitArray256
bool w_S_u8u8u8u8_S_u8u8u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8u8u8_S_u8u8u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8u8u8_>(apis, env, _sv0);
    S_u8u8u8u8_ p0 = pp0 ? *pp0 : S_u8u8u8u8_ {};

    typedef struct S_u8u8u8u8_ (*FuncToCall)(struct S_u8u8u8u8_ p0, const void* method);
    struct S_u8u8u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// UnityEngine.Rendering.BitArray256 op_BitwiseOr(UnityEngine.Rendering.BitArray256, UnityEngine.Rendering.BitArray256) declare in UnityEngine.Rendering.BitArray256
bool w_S_u8u8u8u8_S_u8u8u8u8_S_u8u8u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8u8u8_S_u8u8u8u8_S_u8u8u8u8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8u8u8_>(apis, env, _sv0);
    S_u8u8u8u8_ p0 = pp0 ? *pp0 : S_u8u8u8u8_ {};
    // JSValToCSVal struct
    S_u8u8u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8u8u8_>(apis, env, _sv1);
    S_u8u8u8u8_ p1 = pp1 ? *pp1 : S_u8u8u8u8_ {};

    typedef struct S_u8u8u8u8_ (*FuncToCall)(struct S_u8u8u8u8_ p0, struct S_u8u8u8u8_ p1, const void* method);
    struct S_u8u8u8u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, DataTransfer::CopyValueType(apis, env, ret, TIret));
    return true;
}

// Puerts.ArrayBuffer GetArrayBuffer(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_ai4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_ai4popb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Puerts.ArrayBuffer GetArrayBuffer(IntPtr, IntPtr, Boolean) declare in Puerts.GetValueFromResultImpl
bool w_atppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_atppb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, CSRefToJsValue(apis, env, TIret, ret));
    return true;
}

// Boolean get_MonitoringIsEnabled() declare in System.AppDomain
bool w_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_b");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CollectIncremental(UInt64) declare in UnityEngine.Scripting.GarbageCollector
bool w_bDu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bDu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<uint64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    uint64_t p0 = OptionalParameter<uint64_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef bool (*FuncToCall)(uint64_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDBNull(System.Object) declare in System.Convert
bool w_bO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef bool (*FuncToCall)(Il2CppObject* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsTweening(System.Object, Boolean) declare in DG.Tweening.DOTween
bool w_bODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bODb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Object, System.Object) declare in System.Object
bool w_bOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SetComObjectData(System.Object, System.Object, System.Object) declare in System.Runtime.InteropServices.Marshal
bool w_bOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreEqual(System.Object, System.Object, NUnit.Framework.Constraints.Tolerance ByRef) declare in NUnit.Framework.Constraints.Numerics
bool w_bOOPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOOPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Object, System.Object, Unity.Plastic.Antlr3.Runtime.Tree.ITreeAdaptor) declare in Unity.Plastic.Antlr3.Runtime.Tree.TreeWizard
bool w_bOOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryUnwrapAsObject(System.Object, JetBrains.Lifetimes.Lifetime ByRef) declare in JetBrains.Lifetimes.Lifetime
bool w_bOPS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOPS_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_o_* p1 = DataTransfer::GetPointer<S_o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_o_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_o_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Object, Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bOS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_O_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_O_* pp1 = DataTransfer::GetPointer<S_O_>(apis, env, _sv1);
    S_O_ p1 = pp1 ? *pp1 : S_O_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_O_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryEnter(System.Object, System.TimeSpan) declare in System.Threading.Monitor
bool w_bOS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Wait(System.Object, System.TimeSpan, Boolean) declare in System.Threading.Monitor
bool w_bOS_i8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_i8_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_i8_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Object, System.RuntimeTypeHandle) declare in System.RuntimeTypeHandle
bool w_bOS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(apis, env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_p_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryEnter(System.Object, Int32) declare in System.Threading.Monitor
bool w_bOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Wait(System.Object, Int32, Boolean) declare in System.Threading.Monitor
bool w_bOi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(System.Object, System.IFormatProvider) declare in System.Convert
bool w_bOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryValidateProperty(System.Object, System.ComponentModel.DataAnnotations.ValidationContext, System.Collections.Generic.ICollection`1[System.ComponentModel.DataAnnotations.ValidationResult]) declare in System.ComponentModel.DataAnnotations.Validator
bool w_bOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryValidateObject(System.Object, System.ComponentModel.DataAnnotations.ValidationContext, System.Collections.Generic.ICollection`1[System.ComponentModel.DataAnnotations.ValidationResult], Boolean) declare in System.ComponentModel.DataAnnotations.Validator
bool w_bOoob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOoob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryValidateValue(System.Object, System.ComponentModel.DataAnnotations.ValidationContext, System.Collections.Generic.ICollection`1[System.ComponentModel.DataAnnotations.ValidationResult], System.Collections.Generic.IEnumerable`1[System.ComponentModel.DataAnnotations.ValidationAttribute]) declare in System.ComponentModel.DataAnnotations.Validator
bool w_bOooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ReloadAllNullIn(System.Object, System.String) declare in UnityEngine.Rendering.ResourceReloader
bool w_bOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bOs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseValue(System.Text.Json.Utf8JsonReader ByRef, System.Nullable`1[System.Text.Json.JsonElement] ByRef) declare in System.Text.Json.JsonElement
bool w_bPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__PN_bS_oi4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__PN_bS_oi4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    N_bS_oi4__* p1 = DataTransfer::GetPointer<N_bS_oi4__>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    N_bS_oi4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(N_bS_oi4__));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, struct N_bS_oi4__* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        if (!p1->hasValue) apis->update_boxed_value(env, _sv1, apis->create_null(env));
        if (p1 == &up1) apis->update_boxed_value(env, _sv1, DataTransfer::CopyNullableValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseValue(System.Text.Json.Utf8JsonReader ByRef, System.Text.Json.JsonDocument ByRef) declare in System.Text.Json.JsonDocument
bool w_bPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0 = DataTransfer::GetPointer<S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(struct S_S_S_p_i4_bbi8i8i4bbu1u1S_i4u1bb_S_ou8i4_i8bbbS_Oi4_S_Oi4_S_OOi4i4_S_S_p_i4_i8bbS_OOi4i4__* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsOffscreenDepthTexture(UnityEngine.Rendering.Universal.CameraData ByRef) declare in UnityEngine.Rendering.Universal.UniversalRenderer
bool w_bPS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_* p0 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Flock ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_i2i2i8i8i4_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i2i2i8i8i4_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i2i2i8i8i4_* p0 = DataTransfer::GetPointer<S_i2i2i8i8i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i2i2i8i8i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i2i2i8i8i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i2i2i8i8i4_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Pollfd ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_i4i2i2_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i2i2_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i2i2_* p0 = DataTransfer::GetPointer<S_i4i2i2_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i2i2_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i2i2_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4i2i2_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Linger ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_i4i4_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4_* p0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4i4_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetEntryTimingInfo(UnityEditorInternal.NativeProfilerTimeline_GetEntryTimingInfoArgs ByRef) declare in UnityEditorInternal.NativeProfilerTimeline
bool w_bPS_i4i4i4br4r4r4i4r4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4br4r4r4i4r4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4br4r4r4i4r4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4br4r4r4i4r4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4br4r4r4i4r4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4br4r4r4i4r4i4i4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_i4i4i4br4r4r4i4r4i4i4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetEntryInstanceInfo(UnityEditorInternal.NativeProfilerTimeline_GetEntryInstanceInfoArgs ByRef) declare in UnityEditorInternal.NativeProfilerTimeline
bool w_bPS_i4i4i4i4soss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4i4soss_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4i4soss_* p0 = DataTransfer::GetPointer<S_i4i4i4i4soss_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4soss_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4i4soss_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_i4i4i4i4soss_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetWorkStealingRange(Unity.Jobs.LowLevel.Unsafe.JobRanges ByRef, Int32, Int32 ByRef, Int32 ByRef) declare in Unity.Jobs.LowLevel.Unsafe.JobsUtility
bool w_bPS_i4i4i4p_i4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4p_i4Pi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4p_* p0 = DataTransfer::GetPointer<S_i4i4i4p_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4p_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4p_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_i4i4i4p_* p0, int32_t p1, int32_t* p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetEntryPositionInfo(UnityEditorInternal.NativeProfilerTimeline_GetEntryPositionInfoArgs ByRef) declare in UnityEditorInternal.NativeProfilerTimeline
bool w_bPS_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_* p0 = DataTransfer::GetPointer<S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetEntryAtPosition(UnityEditorInternal.NativeProfilerTimeline_GetEntryAtPositionArgs ByRef) declare in UnityEditorInternal.NativeProfilerTimeline
bool w_bPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_* p0 = DataTransfer::GetPointer<S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Cmsghdr ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_i8i4i4_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i8i4i4_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i8i4i4_* p0 = DataTransfer::GetPointer<S_i8i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i8i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i8i4i4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i8i4i4_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Timespec ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_i8i8_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i8i8_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i8i8_* p0 = DataTransfer::GetPointer<S_i8i8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i8i8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i8i8_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i8i8_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ExtractSpotLightMatrix(UnityEngine.Rendering.CullingResults ByRef, UnityEngine.Rendering.Universal.ShadowData ByRef, Int32, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pPvS_pi4i4__* p0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pPvS_pi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pPvS_pi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1 = DataTransfer::GetPointer<S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p4 = &up4;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p5 = &up5;
    }
        
    // JSValToCSVal Pstruct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p6 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(apis, env, apis->unboxing(env, _sv6)); // valuetype ref
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__));
        p6 = &up6;
    }
        

    typedef bool (*FuncToCall)(struct S_pPvS_pi4i4__* p0, struct S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1, int32_t p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p4, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p5, struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
            
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
            
    if (p6 == &up6)
    {
        apis->update_boxed_value(env, _sv6, DataTransfer::CopyValueType(apis, env, *p6, TIp6));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ExtractDirectionalLightMatrix(UnityEngine.Rendering.CullingResults ByRef, UnityEngine.Rendering.Universal.ShadowData ByRef, Int32, Int32, Int32, Int32, Int32, Single, UnityEngine.Vector4 ByRef, UnityEngine.Rendering.Universal.ShadowSliceData ByRef) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4i4i4i4i4r4PS_r4r4r4r4_PS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4i4i4i4i4r4PS_r4r4r4r4_PS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp8 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!apis->is_boxed_value(env, _sv8)) return false;
        if (!apis->is_boxed_value(env, _sv9)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pPvS_pi4i4__* p0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pPvS_pi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pPvS_pi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1 = DataTransfer::GetPointer<S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p8 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv8)); // valuetype ref
    S_r4r4r4r4_ up8;
    if (!p8) {
        memset(&up8, 0, sizeof(S_r4r4r4r4_));
        p8 = &up8;
    }
        
    // JSValToCSVal Pstruct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___* p9 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___>(apis, env, apis->unboxing(env, _sv9)); // valuetype ref
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___ up9;
    if (!p9) {
        memset(&up9, 0, sizeof(S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___));
        p9 = &up9;
    }
        

    typedef bool (*FuncToCall)(struct S_pPvS_pi4i4__* p0, struct S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, float p7, struct S_r4r4r4r4_* p8, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___* p9, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p8 == &up8)
    {
        apis->update_boxed_value(env, _sv8, DataTransfer::CopyValueType(apis, env, *p8, TIp8));
    }
            
    if (p9 == &up9)
    {
        apis->update_boxed_value(env, _sv9, DataTransfer::CopyValueType(apis, env, *p9, TIp9));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ExtractDirectionalLightMatrix(UnityEngine.Rendering.CullingResults ByRef, UnityEngine.Rendering.Universal.ShadowData ByRef, Int32, Int32, Int32, Int32, Int32, Single, UnityEngine.Vector4 ByRef, UnityEngine.Rendering.Universal.ShadowSliceData ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4i4i4i4i4r4PS_r4r4r4r4_PS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4i4i4i4i4r4PS_r4r4r4r4_PS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp8 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];
    auto TIp11 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);
    pesapi_value _sv11 = apis->get_arg(info, 11);

    if (checkJSArgument) {
        if (js_args_len != 12) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (!apis->is_boxed_value(env, _sv8)) return false;
        if (!apis->is_boxed_value(env, _sv9)) return false;
        if (!apis->is_boxed_value(env, _sv10)) return false;
        if (!apis->is_boxed_value(env, _sv11)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pPvS_pi4i4__* p0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pPvS_pi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pPvS_pi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1 = DataTransfer::GetPointer<S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p8 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv8)); // valuetype ref
    S_r4r4r4r4_ up8;
    if (!p8) {
        memset(&up8, 0, sizeof(S_r4r4r4r4_));
        p8 = &up8;
    }
        
    // JSValToCSVal Pstruct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___* p9 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___>(apis, env, apis->unboxing(env, _sv9)); // valuetype ref
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___ up9;
    if (!p9) {
        memset(&up9, 0, sizeof(S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___));
        p9 = &up9;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p10 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv10)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up10;
    if (!p10) {
        memset(&up10, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p10 = &up10;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p11 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv11)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up11;
    if (!p11) {
        memset(&up11, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p11 = &up11;
    }
        

    typedef bool (*FuncToCall)(struct S_pPvS_pi4i4__* p0, struct S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, float p7, struct S_r4r4r4r4_* p8, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4___* p9, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p10, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p11, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p8 == &up8)
    {
        apis->update_boxed_value(env, _sv8, DataTransfer::CopyValueType(apis, env, *p8, TIp8));
    }
            
    if (p9 == &up9)
    {
        apis->update_boxed_value(env, _sv9, DataTransfer::CopyValueType(apis, env, *p9, TIp9));
    }
            
    if (p10 == &up10)
    {
        apis->update_boxed_value(env, _sv10, DataTransfer::CopyValueType(apis, env, *p10, TIp10));
    }
            
    if (p11 == &up11)
    {
        apis->update_boxed_value(env, _sv11, DataTransfer::CopyValueType(apis, env, *p11, TIp11));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ExtractPointLightMatrix(UnityEngine.Rendering.CullingResults ByRef, UnityEngine.Rendering.Universal.ShadowData ByRef, Int32, UnityEngine.CubemapFace, Single, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4i4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pPvS_pi4i4__PS_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_i4i4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
        if (!apis->is_boxed_value(env, _sv8)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pPvS_pi4i4__* p0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pPvS_pi4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pPvS_pi4i4__));
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1 = DataTransfer::GetPointer<S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p5 = &up5;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p6 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv6)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p6 = &up6;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p7 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv7)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up7;
    if (!p7) {
        memset(&up7, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p7 = &up7;
    }
        
    // JSValToCSVal Pstruct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p8 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(apis, env, apis->unboxing(env, _sv8)); // valuetype ref
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ up8;
    if (!p8) {
        memset(&up8, 0, sizeof(S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__));
        p8 = &up8;
    }
        

    typedef bool (*FuncToCall)(struct S_pPvS_pi4i4__* p0, struct S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_* p1, int32_t p2, int32_t p3, float p4, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p5, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p6, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p7, struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
            
    if (p6 == &up6)
    {
        apis->update_boxed_value(env, _sv6, DataTransfer::CopyValueType(apis, env, *p6, TIp6));
    }
            
    if (p7 == &up7)
    {
        apis->update_boxed_value(env, _sv7, DataTransfer::CopyValueType(apis, env, *p7, TIp7));
    }
            
    if (p8 == &up8)
    {
        apis->update_boxed_value(env, _sv8, DataTransfer::CopyValueType(apis, env, *p8, TIp8));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDefaultValue(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_bPS_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pi4i4_* p0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pi4i4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_pi4i4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Iovec ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_pu8_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pu8_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_pu8_* p0 = DataTransfer::GetPointer<S_pu8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_pu8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_pu8_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_pu8_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ComputeElementBounds(UnityEngine.Rect ByRef, System.Collections.Generic.List`1[UnityEditor.Experimental.GraphView.GraphElement], MinSizePolicy) declare in UnityEditor.Experimental.GraphView.Placemat
bool w_bPS_r4r4r4r4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_r4r4r4r4_oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_* p0, Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsKeywordEnabled(UnityEngine.Rendering.GlobalKeyword ByRef) declare in UnityEngine.Shader
bool w_bPS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_su4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct S_su4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.InAddr ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_u4_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_u4_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u4_* p0 = DataTransfer::GetPointer<S_u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_u4_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.In6Addr ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_u8u8_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_u8u8_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8u8_* p0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8u8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8u8_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_u8u8_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Stat ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* p0 = DataTransfer::GetPointer<S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Statvfs ByRef, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bPS_u8u8u8u8u8u8u8u8u8u8u8_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_u8u8u8u8u8u8u8u8u8u8u8_p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8u8u8u8u8u8u8u8u8u8u8_* p0 = DataTransfer::GetPointer<S_u8u8u8u8u8u8u8u8u8u8u8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8u8u8u8u8u8u8u8u8u8u8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8u8u8u8u8u8u8u8u8u8u8_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_u8u8u8u8u8u8u8u8u8u8u8_* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Read(Boolean ByRef) declare in System.Threading.Volatile
bool w_bPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    bool up0 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv0);
    bool* p0 = &up0;

    typedef bool (*FuncToCall)(bool* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<bool>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetDroppedFrameCount(Int32 ByRef) declare in UnityEngine.XR.XRStats
bool w_bPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;

    typedef bool (*FuncToCall)(int32_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetLightingSettings(UnityEngine.LightingSettings ByRef) declare in UnityEditor.Lightmapping
bool w_bPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef bool (*FuncToCall)(Il2CppObject** p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ReAllocateIfNeeded(UnityEngine.Rendering.RTHandle ByRef, UnityEngine.RenderTextureDescriptor ByRef, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, Boolean, Int32, Single, System.String) declare in UnityEngine.Rendering.Universal.RenderingUtils
bool w_bPoPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPoPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<float>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4i4i4i4i4i4i4i4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    float p6 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal string  with default
    Il2CppString* p7 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef bool (*FuncToCall)(Il2CppObject** p0, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p1, int32_t p2, int32_t p3, bool p4, int32_t p5, float p6, Il2CppString* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ReAllocateIfNeeded(UnityEngine.Rendering.RTHandle ByRef, UnityEngine.Vector2, UnityEngine.RenderTextureDescriptor ByRef, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, Boolean, Int32, Single, System.String) declare in UnityEngine.Rendering.Universal.RenderingUtils
bool w_bPoS_r4r4_PS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPoS_r4r4_PS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p2 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4i4i4i4i4i4i4i4i4i4i4i4i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    float p7 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal string  with default
    Il2CppString* p8 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 8);
                

    typedef bool (*FuncToCall)(Il2CppObject** p0, struct S_r4r4_ p1, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p2, int32_t p3, int32_t p4, bool p5, int32_t p6, float p7, Il2CppString* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ShadowRTReAllocateIfNeeded(UnityEngine.Rendering.RTHandle ByRef, Int32, Int32, Int32, Int32, Single, System.String) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_bPoi4i4i4Di4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPoi4i4i4Di4Dr4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 4) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal string  with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 6);
                

    typedef bool (*FuncToCall)(Il2CppObject** p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, float p5, Il2CppString* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ReAllocateIfNeeded(UnityEngine.Rendering.RTHandle ByRef, UnityEngine.Rendering.ScaleFunc, UnityEngine.RenderTextureDescriptor ByRef, UnityEngine.FilterMode, UnityEngine.TextureWrapMode, Boolean, Int32, Single, System.String) declare in UnityEngine.Rendering.Universal.RenderingUtils
bool w_bPooPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPooPS_i4i4i4i4i4i4i4i4i4i4i4i4i4_Di4Di4DbDi4Dr4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (true) {
        if (js_args_len < 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<float>::accept(apis, env, _sv7)) return false;
        if (js_args_len > 8 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p2 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4i4i4i4i4i4i4i4i4i4i4i4i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal primitive with default
    float p7 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 7);
                
    // JSValToCSVal string  with default
    Il2CppString* p8 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 8);
                

    typedef bool (*FuncToCall)(Il2CppObject** p0, Il2CppObject* p1, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* p2, int32_t p3, int32_t p4, bool p5, int32_t p6, float p7, Il2CppString* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGPUTimeLastFrame(Single ByRef) declare in UnityEngine.XR.XRStats
bool w_bPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;

    typedef bool (*FuncToCall)(float* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryResolveSymlinkFinalPath(System.String ByRef) declare in Codice.Client.Common.Platform
bool w_bPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        

    typedef bool (*FuncToCall)(Il2CppString** p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*) declare in System.Threading.ThreadPool
bool w_bPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bPv");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsNullOrEmpty(Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_O_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};

    typedef bool (*FuncToCall)(struct S_O_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Microsoft.Extensions.Primitives.StringValues, System.Object) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bS_O_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_O_O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_O_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(Microsoft.Extensions.Primitives.StringValues, Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bS_O_S_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_O_S_O_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};
    // JSValToCSVal struct
    S_O_* pp1 = DataTransfer::GetPointer<S_O_>(apis, env, _sv1);
    S_O_ p1 = pp1 ? *pp1 : S_O_ {};

    typedef bool (*FuncToCall)(struct S_O_ p0, struct S_O_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(Microsoft.Extensions.Primitives.StringValues, System.String[]) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bS_O_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_O_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_O_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(Microsoft.Extensions.Primitives.StringValues, System.String) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bS_O_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_O_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_O_ p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Threading.Tasks.ValueTask, System.Threading.Tasks.ValueTask) declare in System.Threading.Tasks.ValueTask
bool w_bS_Oi2b_S_Oi2b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi2b_S_Oi2b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi2b_* pp0 = DataTransfer::GetPointer<S_Oi2b_>(apis, env, _sv0);
    S_Oi2b_ p0 = pp0 ? *pp0 : S_Oi2b_ {};
    // JSValToCSVal struct
    S_Oi2b_* pp1 = DataTransfer::GetPointer<S_Oi2b_>(apis, env, _sv1);
    S_Oi2b_ p1 = pp1 ? *pp1 : S_Oi2b_ {};

    typedef bool (*FuncToCall)(struct S_Oi2b_ p0, struct S_Oi2b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetString(System.ReadOnlyMemory`1[System.Char], System.String ByRef, Int32 ByRef, Int32 ByRef) declare in System.Runtime.InteropServices.MemoryMarshal
bool w_bS_Oi4i4_PsPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi4i4_PsPi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_Oi4i4_ p0, Il2CppString** p1, int32_t* p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Runtime.InteropServices.ArrayWithOffset, System.Runtime.InteropServices.ArrayWithOffset) declare in System.Runtime.InteropServices.ArrayWithOffset
bool w_bS_Oi4i4_S_Oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi4i4_S_Oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};
    // JSValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};

    typedef bool (*FuncToCall)(struct S_Oi4i4_ p0, struct S_Oi4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Render(Unity.Collections.NativeArray`1[System.Single]) declare in UnityEngine.AudioRenderer
bool w_bS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef bool (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Net.Security.SslApplicationProtocol, System.Net.Security.SslApplicationProtocol) declare in System.Net.Security.SslApplicationProtocol
bool w_bS_S_Oi4i4__S_S_Oi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_Oi4i4__S_S_Oi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_Oi4i4__* pp0 = DataTransfer::GetPointer<S_S_Oi4i4__>(apis, env, _sv0);
    S_S_Oi4i4__ p0 = pp0 ? *pp0 : S_S_Oi4i4__ {};
    // JSValToCSVal struct
    S_S_Oi4i4__* pp1 = DataTransfer::GetPointer<S_S_Oi4i4__>(apis, env, _sv1);
    S_S_Oi4i4__ p1 = pp1 ? *pp1 : S_S_Oi4i4__ {};

    typedef bool (*FuncToCall)(struct S_S_Oi4i4__ p0, struct S_S_Oi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleTransformOrigin, UnityEngine.UIElements.StyleTransformOrigin) declare in UnityEngine.UIElements.StyleTransformOrigin
bool w_bS_S_S_r4i4_S_r4i4_r4_i4_S_S_S_r4i4_S_r4i4_r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4i4_S_r4i4_r4_i4_S_S_S_r4i4_S_r4i4_r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4_i4_* pp0 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4_i4_>(apis, env, _sv0);
    S_S_S_r4i4_S_r4i4_r4_i4_ p0 = pp0 ? *pp0 : S_S_S_r4i4_S_r4i4_r4_i4_ {};
    // JSValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4_i4_>(apis, env, _sv1);
    S_S_S_r4i4_S_r4i4_r4_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4i4_r4_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_r4i4_S_r4i4_r4_i4_ p0, struct S_S_S_r4i4_S_r4i4_r4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleTranslate, UnityEngine.UIElements.StyleTranslate) declare in UnityEngine.UIElements.StyleTranslate
bool w_bS_S_S_r4i4_S_r4i4_r4b_i4_S_S_S_r4i4_S_r4i4_r4b_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4i4_S_r4i4_r4b_i4_S_S_S_r4i4_S_r4i4_r4b_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4b_i4_* pp0 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4b_i4_>(apis, env, _sv0);
    S_S_S_r4i4_S_r4i4_r4b_i4_ p0 = pp0 ? *pp0 : S_S_S_r4i4_S_r4i4_r4b_i4_ {};
    // JSValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4b_i4_>(apis, env, _sv1);
    S_S_S_r4i4_S_r4i4_r4b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4i4_r4b_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_r4i4_S_r4i4_r4b_i4_ p0, struct S_S_S_r4i4_S_r4i4_r4b_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleRotate, UnityEngine.UIElements.StyleRotate) declare in UnityEngine.UIElements.StyleRotate
bool w_bS_S_S_r4i4_S_r4r4r4_b_i4_S_S_S_r4i4_S_r4r4r4_b_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4i4_S_r4r4r4_b_i4_S_S_S_r4i4_S_r4r4r4_b_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4i4_S_r4r4r4_b_i4_* pp0 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4r4r4_b_i4_>(apis, env, _sv0);
    S_S_S_r4i4_S_r4r4r4_b_i4_ p0 = pp0 ? *pp0 : S_S_S_r4i4_S_r4r4r4_b_i4_ {};
    // JSValToCSVal struct
    S_S_S_r4i4_S_r4r4r4_b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4r4r4_b_i4_>(apis, env, _sv1);
    S_S_S_r4i4_S_r4r4r4_b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4r4r4_b_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_r4i4_S_r4r4r4_b_i4_ p0, struct S_S_S_r4i4_S_r4r4r4_b_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.VisibleReflectionProbe, UnityEngine.Rendering.VisibleReflectionProbe) declare in UnityEngine.Rendering.VisibleReflectionProbe
bool w_bS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_>(apis, env, _sv0);
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p0 = pp0 ? *pp0 : S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_>(apis, env, _sv1);
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p0, struct S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleScale, UnityEngine.UIElements.StyleScale) declare in UnityEngine.UIElements.StyleScale
bool w_bS_S_S_r4r4r4_b_i4_S_S_S_r4r4r4_b_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4r4r4_b_i4_S_S_S_r4r4r4_b_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4_b_i4_* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4_b_i4_>(apis, env, _sv0);
    S_S_S_r4r4r4_b_i4_ p0 = pp0 ? *pp0 : S_S_S_r4r4r4_b_i4_ {};
    // JSValToCSVal struct
    S_S_S_r4r4r4_b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_b_i4_>(apis, env, _sv1);
    S_S_S_r4r4r4_b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_b_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_r4r4r4_b_i4_ p0, struct S_S_S_r4r4r4_b_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.DrawingSettings, UnityEngine.Rendering.DrawingSettings) declare in UnityEngine.Rendering.DrawingSettings
bool w_bS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ p0, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RenderStateBlock, UnityEngine.Rendering.RenderStateBlock) declare in UnityEngine.Rendering.RenderStateBlock
bool w_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* pp0 = DataTransfer::GetPointer<S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_>(apis, env, _sv0);
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p0 = pp0 ? *pp0 : S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ {};
    // JSValToCSVal struct
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_>(apis, env, _sv1);
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p1 = pp1 ? *pp1 : S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p0, struct S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleBackgroundSize, UnityEngine.UIElements.StyleBackgroundSize) declare in UnityEngine.UIElements.StyleBackgroundSize
bool w_bS_S_i4S_r4i4_S_r4i4__i4_S_S_i4S_r4i4_S_r4i4__i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4S_r4i4_S_r4i4__i4_S_S_i4S_r4i4_S_r4i4__i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4S_r4i4_S_r4i4__i4_* pp0 = DataTransfer::GetPointer<S_S_i4S_r4i4_S_r4i4__i4_>(apis, env, _sv0);
    S_S_i4S_r4i4_S_r4i4__i4_ p0 = pp0 ? *pp0 : S_S_i4S_r4i4_S_r4i4__i4_ {};
    // JSValToCSVal struct
    S_S_i4S_r4i4_S_r4i4__i4_* pp1 = DataTransfer::GetPointer<S_S_i4S_r4i4_S_r4i4__i4_>(apis, env, _sv1);
    S_S_i4S_r4i4_S_r4i4__i4_ p1 = pp1 ? *pp1 : S_S_i4S_r4i4_S_r4i4__i4_ {};

    typedef bool (*FuncToCall)(struct S_S_i4S_r4i4_S_r4i4__i4_ p0, struct S_S_i4S_r4i4_S_r4i4__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleBackgroundPosition, UnityEngine.UIElements.StyleBackgroundPosition) declare in UnityEngine.UIElements.StyleBackgroundPosition
bool w_bS_S_i4S_r4i4__i4_S_S_i4S_r4i4__i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4S_r4i4__i4_S_S_i4S_r4i4__i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4S_r4i4__i4_* pp0 = DataTransfer::GetPointer<S_S_i4S_r4i4__i4_>(apis, env, _sv0);
    S_S_i4S_r4i4__i4_ p0 = pp0 ? *pp0 : S_S_i4S_r4i4__i4_ {};
    // JSValToCSVal struct
    S_S_i4S_r4i4__i4_* pp1 = DataTransfer::GetPointer<S_S_i4S_r4i4__i4_>(apis, env, _sv1);
    S_S_i4S_r4i4__i4_ p1 = pp1 ? *pp1 : S_S_i4S_r4i4__i4_ {};

    typedef bool (*FuncToCall)(struct S_S_i4S_r4i4__i4_ p0, struct S_S_i4S_r4i4__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleBackgroundRepeat, UnityEngine.UIElements.StyleBackgroundRepeat) declare in UnityEngine.UIElements.StyleBackgroundRepeat
bool w_bS_S_i4i4_i4_S_S_i4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4i4_i4_S_S_i4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_i4_* pp0 = DataTransfer::GetPointer<S_S_i4i4_i4_>(apis, env, _sv0);
    S_S_i4i4_i4_ p0 = pp0 ? *pp0 : S_S_i4i4_i4_ {};
    // JSValToCSVal struct
    S_S_i4i4_i4_* pp1 = DataTransfer::GetPointer<S_S_i4i4_i4_>(apis, env, _sv1);
    S_S_i4i4_i4_ p1 = pp1 ? *pp1 : S_S_i4i4_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_i4i4_i4_ p0, struct S_S_i4i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.FilteringSettings, UnityEngine.Rendering.FilteringSettings) declare in UnityEngine.Rendering.FilteringSettings
bool w_bS_S_i4i4_i4u4i4S_i2i2__S_S_i4i4_i4u4i4S_i2i2__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4i4_i4u4i4S_i2i2__S_S_i4i4_i4u4i4S_i2i2__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4_i4u4i4S_i2i2__* pp0 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, _sv0);
    S_S_i4i4_i4u4i4S_i2i2__ p0 = pp0 ? *pp0 : S_S_i4i4_i4u4i4S_i2i2__ {};
    // JSValToCSVal struct
    S_S_i4i4_i4u4i4S_i2i2__* pp1 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2__>(apis, env, _sv1);
    S_S_i4i4_i4u4i4S_i2i2__ p1 = pp1 ? *pp1 : S_S_i4i4_i4u4i4S_i2i2__ {};

    typedef bool (*FuncToCall)(struct S_S_i4i4_i4u4i4S_i2i2__ p0, struct S_S_i4i4_i4u4i4S_i2i2__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.BoundsInt, UnityEngine.BoundsInt) declare in UnityEngine.BoundsInt
bool w_bS_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp0 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv0);
    S_S_i4i4i4_S_i4i4i4__ p0 = pp0 ? *pp0 : S_S_i4i4i4_S_i4i4i4__ {};
    // JSValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(apis, env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};

    typedef bool (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p0, struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(TMPro.HighlightState, TMPro.HighlightState) declare in TMPro.HighlightState
bool w_bS_S_i4u1u1u1u1_S_r4r4r4r4__S_S_i4u1u1u1u1_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4u1u1u1u1_S_r4r4r4r4__S_S_i4u1u1u1u1_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_i4u1u1u1u1_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_i4u1u1u1u1_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_i4u1u1u1u1_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_i4u1u1u1u1_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_i4u1u1u1u1_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_i4u1u1u1u1_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_i4u1u1u1u1_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_i4u1u1u1u1_S_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_i4u1u1u1u1_S_r4r4r4r4__ p0, struct S_S_i4u1u1u1u1_S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Reflection.CustomAttributeNamedArgument, System.Reflection.CustomAttributeNamedArgument) declare in System.Reflection.CustomAttributeNamedArgument
bool w_bS_S_oO_bsoo_S_S_oO_bsoo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_oO_bsoo_S_S_oO_bsoo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_oO_bsoo_* pp0 = DataTransfer::GetPointer<S_S_oO_bsoo_>(apis, env, _sv0);
    S_S_oO_bsoo_ p0 = pp0 ? *pp0 : S_S_oO_bsoo_ {};
    // JSValToCSVal struct
    S_S_oO_bsoo_* pp1 = DataTransfer::GetPointer<S_S_oO_bsoo_>(apis, env, _sv1);
    S_S_oO_bsoo_ p1 = pp1 ? *pp1 : S_S_oO_bsoo_ {};

    typedef bool (*FuncToCall)(struct S_S_oO_bsoo_ p0, struct S_S_oO_bsoo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleCursor, UnityEngine.UIElements.StyleCursor) declare in UnityEngine.UIElements.StyleCursor
bool w_bS_S_oS_r4r4_i4_i4_S_S_oS_r4r4_i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_oS_r4r4_i4_i4_S_S_oS_r4r4_i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_oS_r4r4_i4_i4_* pp0 = DataTransfer::GetPointer<S_S_oS_r4r4_i4_i4_>(apis, env, _sv0);
    S_S_oS_r4r4_i4_i4_ p0 = pp0 ? *pp0 : S_S_oS_r4r4_i4_i4_ {};
    // JSValToCSVal struct
    S_S_oS_r4r4_i4_i4_* pp1 = DataTransfer::GetPointer<S_S_oS_r4r4_i4_i4_>(apis, env, _sv1);
    S_S_oS_r4r4_i4_i4_ p1 = pp1 ? *pp1 : S_S_oS_r4r4_i4_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_oS_r4r4_i4_i4_ p0, struct S_S_oS_r4r4_i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleBackground, UnityEngine.UIElements.StyleBackground) declare in UnityEngine.UIElements.StyleBackground
bool w_bS_S_oooo_i4_S_S_oooo_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_oooo_i4_S_S_oooo_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_oooo_i4_* pp0 = DataTransfer::GetPointer<S_S_oooo_i4_>(apis, env, _sv0);
    S_S_oooo_i4_ p0 = pp0 ? *pp0 : S_S_oooo_i4_ {};
    // JSValToCSVal struct
    S_S_oooo_i4_* pp1 = DataTransfer::GetPointer<S_S_oooo_i4_>(apis, env, _sv1);
    S_S_oooo_i4_ p1 = pp1 ? *pp1 : S_S_oooo_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_oooo_i4_ p0, struct S_S_oooo_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RendererListParams, UnityEngine.Rendering.RendererListParams) declare in UnityEngine.Rendering.RendererListParams
bool w_bS_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* pp0 = DataTransfer::GetPointer<S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(apis, env, _sv0);
    S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p0 = pp0 ? *pp0 : S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ {};
    // JSValToCSVal struct
    S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* pp1 = DataTransfer::GetPointer<S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(apis, env, _sv1);
    S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p1 = pp1 ? *pp1 : S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ {};

    typedef bool (*FuncToCall)(struct S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p0, struct S_S_pPvS_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ShadowDrawingSettings, UnityEngine.Rendering.ShadowDrawingSettings) declare in UnityEngine.Rendering.ShadowDrawingSettings
bool w_bS_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* pp0 = DataTransfer::GetPointer<S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(apis, env, _sv0);
    S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p0 = pp0 ? *pp0 : S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ {};
    // JSValToCSVal struct
    S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* pp1 = DataTransfer::GetPointer<S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(apis, env, _sv1);
    S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p1 = pp1 ? *pp1 : S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p0, struct S_S_pPvS_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(System.ReadOnlySpan`1[System.Byte]) declare in System.BitConverter
bool w_bS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bS_S_p_i4_PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u8_i2_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u8_i2_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_u8_i2_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.DateTimeOffset ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_PS_S_u8_i2_Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_S_u8_i2_Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u8_i2_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u8_i2_));
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_u8_i2_* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Guid ByRef) declare in System.Guid
bool w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.Guid ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Decimal ByRef) declare in System.Decimal
bool w_bS_S_p_i4_PS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i4i4i4i4u8_* p1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i4i4i4i4u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.Decimal ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_PS_i4i4i4i4u8_Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i4i4i4u8_Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i4i4i4i4u8_* p1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4u8_));
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i4i4i4i4u8_* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Numerics.BigInteger ByRef) declare in System.Numerics.BigInteger
bool w_bS_S_p_i4_PS_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i4o_* p1 = DataTransfer::GetPointer<S_i4o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4o_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i4o_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bS_S_p_i4_PS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i8_* p1 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.TimeSpan ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_PS_i8_Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i8_Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i8_* p1 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8_));
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_i8_* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Buffers.StandardFormat ByRef) declare in System.Buffers.StandardFormat
bool w_bS_S_p_i4_PS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_u1u1_* p1 = DataTransfer::GetPointer<S_u1u1_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u1u1_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_u1u1_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_u8_* p1 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.DateTime ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_PS_u8_Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u8_Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_u8_* p1 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8_));
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_u8_* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Boolean ByRef) declare in System.Boolean
bool w_bS_S_p_i4_Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, bool* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Boolean ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_PbPi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PbPi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, bool* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], SByte ByRef) declare in System.SByte
bool w_bS_S_p_i4_Pi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int8_t up1 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv1);
    int8_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int8_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int8_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], SByte ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pi1Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi1Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int8_t up1 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv1);
    int8_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int8_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int8_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Int16 ByRef) declare in System.Int16
bool w_bS_S_p_i4_Pi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int16_t up1 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv1);
    int16_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int16_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Int16 ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pi2Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi2Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int16_t up1 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv1);
    int16_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int16_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int16_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Int32 ByRef) declare in System.Int32
bool w_bS_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Int32 ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pi4Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi4Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Int64 ByRef) declare in System.Int64
bool w_bS_S_p_i4_Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int64_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int64_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Int64 ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pi8Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi8Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int64_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int64_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Version ByRef) declare in System.Version
bool w_bS_S_p_i4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Single ByRef) declare in System.Single
bool w_bS_S_p_i4_Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, float* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<float>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Single ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pr4Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr4Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, float* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<float>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Double ByRef) declare in System.Double
bool w_bS_S_p_i4_Pr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    double up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, double* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<double>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Double ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pr8Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr8Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    double up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, double* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<double>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Byte ByRef) declare in System.Byte
bool w_bS_S_p_i4_Pu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint8_t up1 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv1);
    uint8_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint8_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint8_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Byte ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pu1Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu1Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint8_t up1 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv1);
    uint8_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint8_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint8_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], UInt16 ByRef) declare in System.UInt16
bool w_bS_S_p_i4_Pu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint16_t up1 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv1);
    uint16_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint16_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], UInt16 ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pu2Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu2Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint16_t up1 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv1);
    uint16_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint16_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint16_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], UInt32 ByRef) declare in System.UInt32
bool w_bS_S_p_i4_Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint32_t up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint32_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], UInt32 ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pu4Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu4Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint32_t up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint32_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], UInt64 ByRef) declare in System.UInt64
bool w_bS_S_p_i4_Pu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint64_t up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint64_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint64_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], UInt64 ByRef, Int32 ByRef, Char) declare in System.Buffers.Text.Utf8Parser
bool w_bS_S_p_i4_Pu8Pi4Dc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu8Pi4Dc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    uint64_t up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    Il2CppChar p3 = OptionalParameter<Il2CppChar>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint64_t* p1, int32_t* p2, Il2CppChar p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint64_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FixedTimeEquals(System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte]) declare in System.Security.Cryptography.CryptographicOperations
bool w_bS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean MatchesWin32Expression(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], Boolean) declare in System.IO.Enumeration.FileSystemName
bool w_bS_S_p_i4_S_S_p_i4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Guid ByRef) declare in System.Guid
bool w_bS_S_p_i4_S_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFromBase64Chars(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Byte], Int32 ByRef) declare in System.Convert
bool w_bS_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryToBase64Chars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char], Int32 ByRef, System.Base64FormattingOptions) declare in System.Convert
bool w_bS_S_p_i4_S_S_p_i4_Pi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCompress(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], Int32 ByRef, Int32, Int32) declare in System.IO.Compression.BrotliEncoder
bool w_bS_S_p_i4_S_S_p_i4_Pi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, int32_t* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryJoin(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], Int32 ByRef) declare in System.IO.Path
bool w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryJoin(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], Int32 ByRef) declare in System.IO.Path
bool w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, int32_t* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<int32_t>::toScript(apis, env, *p4));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bS_S_p_i4_S_S_p_i4_oPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i8_* p3 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, struct S_i8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bS_S_p_i4_S_S_p_i4_oi4PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p4 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_u8_i2_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_u8_i2_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, struct S_S_u8_i2_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bS_S_p_i4_S_S_p_i4_oi4PS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_i8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, struct S_i8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_S_S_p_i4_oi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_u8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, struct S_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Boolean) declare in System.BitConverter
bool w_bS_S_p_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Char) declare in System.BitConverter
bool w_bS_S_p_i4_c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_c");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Int16) declare in System.BitConverter
bool w_bS_S_p_i4_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Int32) declare in System.BitConverter
bool w_bS_S_p_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, System.Decimal ByRef) declare in System.Decimal
bool w_bS_S_p_i4_i4oPS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i4i4i4i4u8_* p3 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4i4i4i4u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i4i4i4i4u8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, struct S_i4i4i4i4u8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, System.Numerics.BigInteger ByRef) declare in System.Numerics.BigInteger
bool w_bS_S_p_i4_i4oPS_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPS_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i4o_* p3 = DataTransfer::GetPointer<S_i4o_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4o_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i4o_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, struct S_i4o_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, SByte ByRef) declare in System.SByte
bool w_bS_S_p_i4_i4oPi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int8_t up3 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv3);
    int8_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, int8_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int8_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Int16 ByRef) declare in System.Int16
bool w_bS_S_p_i4_i4oPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int16_t up3 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv3);
    int16_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, int16_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int16_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Int32 ByRef) declare in System.Int32
bool w_bS_S_p_i4_i4oPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Int64 ByRef) declare in System.Int64
bool w_bS_S_p_i4_i4oPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv3);
    int64_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, int64_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int64_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Single ByRef) declare in System.Single
bool w_bS_S_p_i4_i4oPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, float* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<float>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Double ByRef) declare in System.Double
bool w_bS_S_p_i4_i4oPr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPr8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    double up3 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv3);
    double* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, double* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<double>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Byte ByRef) declare in System.Byte
bool w_bS_S_p_i4_i4oPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint8_t up3 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv3);
    uint8_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, uint8_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint8_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, UInt16 ByRef) declare in System.UInt16
bool w_bS_S_p_i4_i4oPu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint16_t up3 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv3);
    uint16_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, uint16_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint16_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, UInt32 ByRef) declare in System.UInt32
bool w_bS_S_p_i4_i4oPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, uint32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, UInt64 ByRef) declare in System.UInt64
bool w_bS_S_p_i4_i4oPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint64_t up3 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv3);
    uint64_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int32_t p1, Il2CppObject* p2, uint64_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint64_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Int64) declare in System.BitConverter
bool w_bS_S_p_i4_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bS_S_p_i4_oPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_i8_* p2 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i8_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, struct S_i8_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bS_S_p_i4_oi4PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oi4PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p3 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_u8_i2_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_u8_i2_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, int32_t p2, struct S_S_u8_i2_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_oi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oi4PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Pstruct
    S_u8_* p3 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_u8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, int32_t p2, struct S_u8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bS_S_p_i4_ooPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i8_* p3 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, struct S_i8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bS_S_p_i4_ooi4PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p4 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_u8_i2_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_u8_i2_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_S_u8_i2_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bS_S_p_i4_ooi4PS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_i8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_i8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_ooi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_u8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Single) declare in System.BitConverter
bool w_bS_S_p_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], Double) declare in System.BitConverter
bool w_bS_S_p_i4_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, double p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], UInt16) declare in System.BitConverter
bool w_bS_S_p_i4_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_u2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], UInt32) declare in System.BitConverter
bool w_bS_S_p_i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_u4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryWriteBytes(System.Span`1[System.Byte], UInt64) declare in System.BitConverter
bool w_bS_S_p_i4_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p0, uint64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.LocalKeyword, UnityEngine.Rendering.LocalKeyword) declare in UnityEngine.Rendering.LocalKeyword
bool w_bS_S_p_su4_S_S_p_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_su4_S_S_p_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_p_su4_* pp0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, _sv0);
    S_S_p_su4_ p0 = pp0 ? *pp0 : S_S_p_su4_ {};
    // JSValToCSVal struct
    S_S_p_su4_* pp1 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, _sv1);
    S_S_p_su4_ p1 = pp1 ? *pp1 : S_S_p_su4_ {};

    typedef bool (*FuncToCall)(struct S_S_p_su4_ p0, struct S_S_p_su4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.TransformOrigin, UnityEngine.UIElements.TransformOrigin) declare in UnityEngine.UIElements.TransformOrigin
bool w_bS_S_r4i4_S_r4i4_r4_S_S_r4i4_S_r4i4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_S_r4i4_r4_S_S_r4i4_S_r4i4_r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(apis, env, _sv0);
    S_S_r4i4_S_r4i4_r4_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4i4_r4_ {};
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(apis, env, _sv1);
    S_S_r4i4_S_r4i4_r4_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4_ p0, struct S_S_r4i4_S_r4i4_r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.Translate, UnityEngine.UIElements.Translate) declare in UnityEngine.UIElements.Translate
bool w_bS_S_r4i4_S_r4i4_r4b_S_S_r4i4_S_r4i4_r4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_S_r4i4_r4b_S_S_r4i4_S_r4i4_r4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(apis, env, _sv0);
    S_S_r4i4_S_r4i4_r4b_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4i4_r4b_ {};
    // JSValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(apis, env, _sv1);
    S_S_r4i4_S_r4i4_r4b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4b_ {};

    typedef bool (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4b_ p0, struct S_S_r4i4_S_r4i4_r4b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.Rotate, UnityEngine.UIElements.Rotate) declare in UnityEngine.UIElements.Rotate
bool w_bS_S_r4i4_S_r4r4r4_b_S_S_r4i4_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_S_r4r4r4_b_S_S_r4i4_S_r4r4r4_b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp0 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(apis, env, _sv0);
    S_S_r4i4_S_r4r4r4_b_ p0 = pp0 ? *pp0 : S_S_r4i4_S_r4r4r4_b_ {};
    // JSValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(apis, env, _sv1);
    S_S_r4i4_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4r4r4_b_ {};

    typedef bool (*FuncToCall)(struct S_S_r4i4_S_r4r4r4_b_ p0, struct S_S_r4i4_S_r4r4r4_b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleLength, UnityEngine.UIElements.StyleLength) declare in UnityEngine.UIElements.StyleLength
bool w_bS_S_r4i4_i4_S_S_r4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_i4_S_S_r4i4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4i4_i4_* pp0 = DataTransfer::GetPointer<S_S_r4i4_i4_>(apis, env, _sv0);
    S_S_r4i4_i4_ p0 = pp0 ? *pp0 : S_S_r4i4_i4_ {};
    // JSValToCSVal struct
    S_S_r4i4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_i4_>(apis, env, _sv1);
    S_S_r4i4_i4_ p1 = pp1 ? *pp1 : S_S_r4i4_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4i4_i4_ p0, struct S_S_r4i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Implicit(UnityEngine.RaycastHit2D) declare in UnityEngine.RaycastHit2D
bool w_bS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_>(apis, env, _sv0);
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p0 = pp0 ? *pp0 : S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.TextShadow, UnityEngine.UIElements.TextShadow) declare in UnityEngine.UIElements.TextShadow
bool w_bS_S_r4r4_r4S_r4r4r4r4__S_S_r4r4_r4S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4_r4S_r4r4r4r4__S_S_r4r4_r4S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4_r4S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_r4S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4_r4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_r4S_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4_r4S_r4r4r4r4__ p0, struct S_S_r4r4_r4S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single, Int32) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Bounds, UnityEngine.Bounds) declare in UnityEngine.Bounds
bool w_bS_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IntersectRaySphere(UnityEngine.Ray, UnityEngine.Vector3, Single, Single ByRef, UnityEngine.Vector3 ByRef) declare in UnityEditor.MathUtils
bool w_bS_S_r4r4r4_S_r4r4r4__S_r4r4r4_r4Pr4PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__S_r4r4r4_r4Pr4PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;
    // JSValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_r4r4r4_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, struct S_r4r4r4_ p1, float p2, float* p3, struct S_r4r4r4_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<float>::toScript(apis, env, *p3));
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, Single) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single, Int32) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, Single, Int32) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Ray, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, Single) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, Single, Int32) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_S_r4r4r4_S_r4r4r4__r4r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p0, float p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Pose, UnityEngine.Pose) declare in UnityEngine.Pose
bool w_bS_S_r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4_S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.Scale, UnityEngine.UIElements.Scale) declare in UnityEngine.UIElements.Scale
bool w_bS_S_r4r4r4_b_S_S_r4r4r4_b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_b_S_S_r4r4r4_b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_b_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(apis, env, _sv0);
    S_S_r4r4r4_b_ p0 = pp0 ? *pp0 : S_S_r4r4r4_b_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(apis, env, _sv1);
    S_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4r4r4_b_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_b_ p0, struct S_S_r4r4r4_b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Numerics.Plane, System.Numerics.Plane) declare in System.Numerics.Plane
bool w_bS_S_r4r4r4_r4_S_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_r4_S_S_r4r4r4_r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4_r4_ p0, struct S_S_r4r4r4_r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.CameraProperties, UnityEngine.Rendering.CameraProperties) declare in UnityEngine.Rendering.CameraProperties
bool w_bS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p0, struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.BatchRendererGroupGlobals, UnityEngine.Rendering.BatchRendererGroupGlobals) declare in UnityEngine.Rendering.BatchRendererGroupGlobals
bool w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4___ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.SHCoefficients, UnityEngine.Rendering.SHCoefficients) declare in UnityEngine.Rendering.SHCoefficients
bool w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UI.ColorBlock, UnityEngine.UI.ColorBlock) declare in UnityEngine.UI.ColorBlock
bool w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.SphericalHarmonicsL1, UnityEngine.Rendering.SphericalHarmonicsL1) declare in UnityEngine.Rendering.SphericalHarmonicsL1
bool w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Timeline.MarkerOverlayRegion, UnityEditor.Timeline.MarkerOverlayRegion) declare in UnityEditor.Timeline.MarkerOverlayRegion
bool w_bS_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_>(apis, env, _sv0);
    S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_>(apis, env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_ p0, struct S_S_r4r4r4r4_S_r4r4r4r4_r8r8r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleColor, UnityEngine.UIElements.StyleColor) declare in UnityEngine.UIElements.StyleColor
bool w_bS_S_r4r4r4r4_i4_S_S_r4r4r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_i4_S_S_r4r4r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(apis, env, _sv0);
    S_S_r4r4r4r4_i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_i4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(apis, env, _sv1);
    S_S_r4r4r4r4_i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_i4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_i4_ p0, struct S_S_r4r4r4r4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleColor, UnityEngine.Color) declare in UnityEngine.UIElements.StyleColor
bool w_bS_S_r4r4r4r4_i4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_i4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(apis, env, _sv0);
    S_S_r4r4r4r4_i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_i4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_i4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Timeline.ClipBackgroundRegion, UnityEditor.Timeline.ClipBackgroundRegion) declare in UnityEditor.Timeline.ClipBackgroundRegion
bool w_bS_S_r4r4r4r4_r8r8_S_S_r4r4r4r4_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_r8r8_S_S_r4r4r4r4_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4_r8r8_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4_r8r8_>(apis, env, _sv0);
    S_S_r4r4r4r4_r8r8_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4_r8r8_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4_r8r8_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_r8r8_>(apis, env, _sv1);
    S_S_r4r4r4r4_r8r8_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_r8r8_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_r8r8_ p0, struct S_S_r4r4r4r4_r8r8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.SortingSettings, UnityEngine.Rendering.SortingSettings) declare in UnityEngine.Rendering.SortingSettings
bool w_bS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(apis, env, _sv0);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p0 = pp0 ? *pp0 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};
    // JSValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(apis, env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p0, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Diagnostics.ActivityContext, System.Diagnostics.ActivityContext) declare in System.Diagnostics.ActivityContext
bool w_bS_S_s_S_s_i4sb_S_S_s_S_s_i4sb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_s_S_s_i4sb_S_S_s_S_s_i4sb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_s_S_s_i4sb_* pp0 = DataTransfer::GetPointer<S_S_s_S_s_i4sb_>(apis, env, _sv0);
    S_S_s_S_s_i4sb_ p0 = pp0 ? *pp0 : S_S_s_S_s_i4sb_ {};
    // JSValToCSVal struct
    S_S_s_S_s_i4sb_* pp1 = DataTransfer::GetPointer<S_S_s_S_s_i4sb_>(apis, env, _sv1);
    S_S_s_S_s_i4sb_ p1 = pp1 ? *pp1 : S_S_s_S_s_i4sb_ {};

    typedef bool (*FuncToCall)(struct S_S_s_S_s_i4sb_ p0, struct S_S_s_S_s_i4sb_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.BlendState, UnityEngine.Rendering.BlendState) declare in UnityEngine.Rendering.BlendState
bool w_bS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_* pp0 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_>(apis, env, _sv0);
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p0 = pp0 ? *pp0 : S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ {};
    // JSValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_>(apis, env, _sv1);
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ {};

    typedef bool (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p0, struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord, UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord) declare in UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord
bool w_bS_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_* pp0 = DataTransfer::GetPointer<S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_>(apis, env, _sv0);
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p0 = pp0 ? *pp0 : S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ {};
    // JSValToCSVal struct
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_* pp1 = DataTransfer::GetPointer<S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_>(apis, env, _sv1);
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p1 = pp1 ? *pp1 : S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ {};

    typedef bool (*FuncToCall)(struct S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p0, struct S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Build.Content.ObjectIdentifier, UnityEditor.Build.Content.ObjectIdentifier) declare in UnityEditor.Build.Content.ObjectIdentifier
bool w_bS_S_u4u4u4u4_i8i4s_S_S_u4u4u4u4_i8i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u4u4u4u4_i8i4s_S_S_u4u4u4u4_i8i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp0 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv0);
    S_S_u4u4u4u4_i8i4s_ p0 = pp0 ? *pp0 : S_S_u4u4u4u4_i8i4s_ {};
    // JSValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, _sv1);
    S_S_u4u4u4u4_i8i4s_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_i8i4s_ {};

    typedef bool (*FuncToCall)(struct S_S_u4u4u4u4_i8i4s_ p0, struct S_S_u4u4u4u4_i8i4s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(System.DateTimeOffset, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bS_S_u8_i2_S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8_i2_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_S_u8_i2_ p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.DateTimeOffset, System.DateTimeOffset) declare in System.DateTimeOffset
bool w_bS_S_u8_i2_S_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8_i2_S_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8_i2_* pp0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv0);
    S_S_u8_i2_ p0 = pp0 ? *pp0 : S_S_u8_i2_ {};
    // JSValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};

    typedef bool (*FuncToCall)(struct S_S_u8_i2_ p0, struct S_S_u8_i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetArtifactPaths(UnityEditor.Experimental.ArtifactID, System.String[] ByRef) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_bS_S_u8u8__Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8__Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8__* pp0 = DataTransfer::GetPointer<S_S_u8u8__>(apis, env, _sv0);
    S_S_u8u8__ p0 = pp0 ? *pp0 : S_S_u8u8__ {};
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(struct S_S_u8u8__ p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.MeshInfo, UnityEngine.XR.MeshInfo) declare in UnityEngine.XR.MeshInfo
bool w_bS_S_u8u8_i4i4_S_S_u8u8_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8_i4i4_S_S_u8u8_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8_i4i4_* pp0 = DataTransfer::GetPointer<S_S_u8u8_i4i4_>(apis, env, _sv0);
    S_S_u8u8_i4i4_ p0 = pp0 ? *pp0 : S_S_u8u8_i4i4_ {};
    // JSValToCSVal struct
    S_S_u8u8_i4i4_* pp1 = DataTransfer::GetPointer<S_S_u8u8_i4i4_>(apis, env, _sv1);
    S_S_u8u8_i4i4_ p1 = pp1 ? *pp1 : S_S_u8u8_i4i4_ {};

    typedef bool (*FuncToCall)(struct S_S_u8u8_i4i4_ p0, struct S_S_u8u8_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.MeshGenerationResult, UnityEngine.XR.MeshGenerationResult) declare in UnityEngine.XR.MeshGenerationResult
bool w_bS_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p0, struct S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.MeshTransform, UnityEngine.XR.MeshTransform) declare in UnityEngine.XR.MeshTransform
bool w_bS_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
    // JSValToCSVal struct
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p0, struct S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.SceneManagement.StageHandle, UnityEditor.SceneManagement.StageHandle) declare in UnityEditor.SceneManagement.StageHandle
bool w_bS_bS_i4__S_bS_i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bS_i4__S_bS_i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bS_i4__* pp0 = DataTransfer::GetPointer<S_bS_i4__>(apis, env, _sv0);
    S_bS_i4__ p0 = pp0 ? *pp0 : S_bS_i4__ {};
    // JSValToCSVal struct
    S_bS_i4__* pp1 = DataTransfer::GetPointer<S_bS_i4__>(apis, env, _sv1);
    S_bS_i4__ p1 = pp1 ? *pp1 : S_bS_i4__ {};

    typedef bool (*FuncToCall)(struct S_bS_i4__ p0, struct S_bS_i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.bool2) declare in Unity.Mathematics.math
bool w_bS_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};

    typedef bool (*FuncToCall)(struct S_bb_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean shuffle(Unity.Mathematics.bool2, Unity.Mathematics.bool2, ShuffleComponent) declare in Unity.Mathematics.math
bool w_bS_bb_S_bb_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bb_S_bb_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_bb_* pp0 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv0);
    S_bb_ p0 = pp0 ? *pp0 : S_bb_ {};
    // JSValToCSVal struct
    S_bb_* pp1 = DataTransfer::GetPointer<S_bb_>(apis, env, _sv1);
    S_bb_ p1 = pp1 ? *pp1 : S_bb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_bb_ p0, struct S_bb_ p1, uint8_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.bool3) declare in Unity.Mathematics.math
bool w_bS_bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};

    typedef bool (*FuncToCall)(struct S_bbb_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean shuffle(Unity.Mathematics.bool3, Unity.Mathematics.bool3, ShuffleComponent) declare in Unity.Mathematics.math
bool w_bS_bbb_S_bbb_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bbb_S_bbb_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_bbb_* pp0 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv0);
    S_bbb_ p0 = pp0 ? *pp0 : S_bbb_ {};
    // JSValToCSVal struct
    S_bbb_* pp1 = DataTransfer::GetPointer<S_bbb_>(apis, env, _sv1);
    S_bbb_ p1 = pp1 ? *pp1 : S_bbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_bbb_ p0, struct S_bbb_ p1, uint8_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.bool4) declare in Unity.Mathematics.math
bool w_bS_bbbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bbbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};

    typedef bool (*FuncToCall)(struct S_bbbb_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean shuffle(Unity.Mathematics.bool4, Unity.Mathematics.bool4, ShuffleComponent) declare in Unity.Mathematics.math
bool w_bS_bbbb_S_bbbb_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bbbb_S_bbbb_u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_bbbb_* pp0 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv0);
    S_bbbb_ p0 = pp0 ? *pp0 : S_bbbb_ {};
    // JSValToCSVal struct
    S_bbbb_* pp1 = DataTransfer::GetPointer<S_bbbb_>(apis, env, _sv1);
    S_bbbb_ p1 = pp1 ? *pp1 : S_bbbb_ {};
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_bbbb_ p0, struct S_bbbb_ p1, uint8_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Threading.AsyncFlowControl, System.Threading.AsyncFlowControl) declare in System.Threading.AsyncFlowControl
bool w_bS_boo_S_boo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_boo_S_boo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_boo_* pp0 = DataTransfer::GetPointer<S_boo_>(apis, env, _sv0);
    S_boo_ p0 = pp0 ? *pp0 : S_boo_ {};
    // JSValToCSVal struct
    S_boo_* pp1 = DataTransfer::GetPointer<S_boo_>(apis, env, _sv1);
    S_boo_ p1 = pp1 ? *pp1 : S_boo_ {};

    typedef bool (*FuncToCall)(struct S_boo_ p0, struct S_boo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.ConsoleKeyInfo, System.ConsoleKeyInfo) declare in System.ConsoleKeyInfo
bool w_bS_ci4i4_S_ci4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_ci4i4_S_ci4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ci4i4_* pp0 = DataTransfer::GetPointer<S_ci4i4_>(apis, env, _sv0);
    S_ci4i4_ p0 = pp0 ? *pp0 : S_ci4i4_ {};
    // JSValToCSVal struct
    S_ci4i4_* pp1 = DataTransfer::GetPointer<S_ci4i4_>(apis, env, _sv1);
    S_ci4i4_ p1 = pp1 ? *pp1 : S_ci4i4_ {};

    typedef bool (*FuncToCall)(struct S_ci4i4_ p0, struct S_ci4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasSpriteMaskInLayerRange(UnityEngine.Rendering.SortingLayerRange) declare in UnityEngine.SpriteMaskUtility
bool w_bS_i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i2i2_* pp0 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv0);
    S_i2i2_ p0 = pp0 ? *pp0 : S_i2i2_ {};

    typedef bool (*FuncToCall)(struct S_i2i2_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Inequality(UnityEngine.Rendering.SortingLayerRange, UnityEngine.Rendering.SortingLayerRange) declare in UnityEngine.Rendering.SortingLayerRange
bool w_bS_i2i2_S_i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i2i2_S_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i2i2_* pp0 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv0);
    S_i2i2_ p0 = pp0 ? *pp0 : S_i2i2_ {};
    // JSValToCSVal struct
    S_i2i2_* pp1 = DataTransfer::GetPointer<S_i2i2_>(apis, env, _sv1);
    S_i2i2_ p1 = pp1 ? *pp1 : S_i2i2_ {};

    typedef bool (*FuncToCall)(struct S_i2i2_ p0, struct S_i2i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Mono.Unix.Native.Flock, Mono.Unix.Native.Flock) declare in Mono.Unix.Native.Flock
bool w_bS_i2i2i8i8i4_S_i2i2i8i8i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i2i2i8i8i4_S_i2i2i8i8i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i2i2i8i8i4_* pp0 = DataTransfer::GetPointer<S_i2i2i8i8i4_>(apis, env, _sv0);
    S_i2i2i8i8i4_ p0 = pp0 ? *pp0 : S_i2i2i8i8i4_ {};
    // JSValToCSVal struct
    S_i2i2i8i8i4_* pp1 = DataTransfer::GetPointer<S_i2i2i8i8i4_>(apis, env, _sv1);
    S_i2i2i8i8i4_ p1 = pp1 ? *pp1 : S_i2i2i8i8i4_ {};

    typedef bool (*FuncToCall)(struct S_i2i2i8i8i4_ p0, struct S_i2i2i8i8i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleTextShadow, UnityEngine.UIElements.StyleTextShadow) declare in UnityEngine.UIElements.StyleTextShadow
bool w_bS_i4S_S_r4r4_r4S_r4r4r4r4___S_i4S_S_r4r4_r4S_r4r4r4r4___(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_S_r4r4_r4S_r4r4r4r4___S_i4S_S_r4r4_r4S_r4r4r4r4___");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_S_r4r4_r4S_r4r4r4r4___* pp0 = DataTransfer::GetPointer<S_i4S_S_r4r4_r4S_r4r4r4r4___>(apis, env, _sv0);
    S_i4S_S_r4r4_r4S_r4r4r4r4___ p0 = pp0 ? *pp0 : S_i4S_S_r4r4_r4S_r4r4r4r4___ {};
    // JSValToCSVal struct
    S_i4S_S_r4r4_r4S_r4r4r4r4___* pp1 = DataTransfer::GetPointer<S_i4S_S_r4r4_r4S_r4r4r4r4___>(apis, env, _sv1);
    S_i4S_S_r4r4_r4S_r4r4r4r4___ p1 = pp1 ? *pp1 : S_i4S_S_r4r4_r4S_r4r4r4r4___ {};

    typedef bool (*FuncToCall)(struct S_i4S_S_r4r4_r4S_r4r4r4r4___ p0, struct S_i4S_S_r4r4_r4S_r4r4r4r4___ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ScriptableCullingParameters, UnityEngine.Rendering.ScriptableCullingParameters) declare in UnityEngine.Rendering.ScriptableCullingParameters
bool w_bS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* pp0 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(apis, env, _sv0);
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p0 = pp0 ? *pp0 : S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ {};
    // JSValToCSVal struct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* pp1 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(apis, env, _sv1);
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p1 = pp1 ? *pp1 : S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ {};

    typedef bool (*FuncToCall)(struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p0, struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.Universal.RenderTargetHandle, UnityEngine.Rendering.Universal.RenderTargetHandle) declare in UnityEngine.Rendering.Universal.RenderTargetHandle
bool w_bS_i4S_i4i4i4pi4i4i4__S_i4S_i4i4i4pi4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_i4i4i4pi4i4i4__S_i4S_i4i4i4pi4i4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_i4i4i4pi4i4i4__* pp0 = DataTransfer::GetPointer<S_i4S_i4i4i4pi4i4i4__>(apis, env, _sv0);
    S_i4S_i4i4i4pi4i4i4__ p0 = pp0 ? *pp0 : S_i4S_i4i4i4pi4i4i4__ {};
    // JSValToCSVal struct
    S_i4S_i4i4i4pi4i4i4__* pp1 = DataTransfer::GetPointer<S_i4S_i4i4i4pi4i4i4__>(apis, env, _sv1);
    S_i4S_i4i4i4pi4i4i4__ p1 = pp1 ? *pp1 : S_i4S_i4i4i4pi4i4i4__ {};

    typedef bool (*FuncToCall)(struct S_i4S_i4i4i4pi4i4i4__ p0, struct S_i4S_i4i4i4pi4i4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Transactions.TransactionOptions, System.Transactions.TransactionOptions) declare in System.Transactions.TransactionOptions
bool w_bS_i4S_i8__S_i4S_i8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_i8__S_i4S_i8__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_i8__* pp0 = DataTransfer::GetPointer<S_i4S_i8__>(apis, env, _sv0);
    S_i4S_i8__ p0 = pp0 ? *pp0 : S_i4S_i8__ {};
    // JSValToCSVal struct
    S_i4S_i8__* pp1 = DataTransfer::GetPointer<S_i4S_i8__>(apis, env, _sv1);
    S_i4S_i8__ p1 = pp1 ? *pp1 : S_i4S_i8__ {};

    typedef bool (*FuncToCall)(struct S_i4S_i8__ p0, struct S_i4S_i8__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleFontDefinition, UnityEngine.UIElements.StyleFontDefinition) declare in UnityEngine.UIElements.StyleFontDefinition
bool w_bS_i4S_oo__S_i4S_oo__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_oo__S_i4S_oo__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_oo__* pp0 = DataTransfer::GetPointer<S_i4S_oo__>(apis, env, _sv0);
    S_i4S_oo__ p0 = pp0 ? *pp0 : S_i4S_oo__ {};
    // JSValToCSVal struct
    S_i4S_oo__* pp1 = DataTransfer::GetPointer<S_i4S_oo__>(apis, env, _sv1);
    S_i4S_oo__ p1 = pp1 ? *pp1 : S_i4S_oo__ {};

    typedef bool (*FuncToCall)(struct S_i4S_oo__ p0, struct S_i4S_oo__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.BackgroundSize, UnityEngine.UIElements.BackgroundSize) declare in UnityEngine.UIElements.BackgroundSize
bool w_bS_i4S_r4i4_S_r4i4__S_i4S_r4i4_S_r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4i4_S_r4i4__S_i4S_r4i4_S_r4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp0 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(apis, env, _sv0);
    S_i4S_r4i4_S_r4i4__ p0 = pp0 ? *pp0 : S_i4S_r4i4_S_r4i4__ {};
    // JSValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(apis, env, _sv1);
    S_i4S_r4i4_S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4_S_r4i4__ {};

    typedef bool (*FuncToCall)(struct S_i4S_r4i4_S_r4i4__ p0, struct S_i4S_r4i4_S_r4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.BackgroundPosition, UnityEngine.UIElements.BackgroundPosition) declare in UnityEngine.UIElements.BackgroundPosition
bool w_bS_i4S_r4i4__S_i4S_r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4i4__S_i4S_r4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4i4__* pp0 = DataTransfer::GetPointer<S_i4S_r4i4__>(apis, env, _sv0);
    S_i4S_r4i4__ p0 = pp0 ? *pp0 : S_i4S_r4i4__ {};
    // JSValToCSVal struct
    S_i4S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4__>(apis, env, _sv1);
    S_i4S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4__ {};

    typedef bool (*FuncToCall)(struct S_i4S_r4i4__ p0, struct S_i4S_r4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.LODParameters, UnityEngine.Rendering.LODParameters) declare in UnityEngine.Rendering.LODParameters
bool w_bS_i4S_r4r4r4_r4r4i4_S_i4S_r4r4r4_r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4r4r4_r4r4i4_S_i4S_r4r4r4_r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4r4r4_r4r4i4_* pp0 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4r4i4_>(apis, env, _sv0);
    S_i4S_r4r4r4_r4r4i4_ p0 = pp0 ? *pp0 : S_i4S_r4r4r4_r4r4i4_ {};
    // JSValToCSVal struct
    S_i4S_r4r4r4_r4r4i4_* pp1 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4r4i4_>(apis, env, _sv1);
    S_i4S_r4r4r4_r4r4i4_ p1 = pp1 ? *pp1 : S_i4S_r4r4r4_r4r4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4S_r4r4r4_r4r4i4_ p0, struct S_i4S_r4r4r4_r4r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.VisibleLight, UnityEngine.Rendering.VisibleLight) declare in UnityEngine.Rendering.VisibleLight
bool w_bS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* pp0 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_>(apis, env, _sv0);
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p0 = pp0 ? *pp0 : S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ {};
    // JSValToCSVal struct
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* pp1 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_>(apis, env, _sv1);
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p1 = pp1 ? *pp1 : S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p0, struct S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ShadowSplitData, UnityEngine.Rendering.ShadowSplitData) declare in UnityEngine.Rendering.ShadowSplitData
bool w_bS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(apis, env, _sv0);
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p0 = pp0 ? *pp0 : S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};
    // JSValToCSVal struct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(apis, env, _sv1);
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p1 = pp1 ? *pp1 : S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p0, struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RemoveCache(UnityEngine.Cache) declare in UnityEngine.Caching
bool w_bS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};

    typedef bool (*FuncToCall)(struct S_i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Reflection.Emit.EventToken, System.Reflection.Emit.EventToken) declare in System.Reflection.Emit.EventToken
bool w_bS_i4_S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_S_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef bool (*FuncToCall)(struct S_i4_ p0, struct S_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CloseScene(UnityEngine.SceneManagement.Scene, Boolean) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_bS_i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SaveScene(UnityEngine.SceneManagement.Scene, System.String) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_bS_i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4_ p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SaveScene(UnityEngine.SceneManagement.Scene, System.String, Boolean) declare in UnityEditor.SceneManagement.EditorSceneManager
bool w_bS_i4_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_sb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_i4_ p0, Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Mono.Unix.Native.Pollfd, Mono.Unix.Native.Pollfd) declare in Mono.Unix.Native.Pollfd
bool w_bS_i4i2i2_S_i4i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i2i2_S_i4i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2_* pp0 = DataTransfer::GetPointer<S_i4i2i2_>(apis, env, _sv0);
    S_i4i2i2_ p0 = pp0 ? *pp0 : S_i4i2i2_ {};
    // JSValToCSVal struct
    S_i4i2i2_* pp1 = DataTransfer::GetPointer<S_i4i2i2_>(apis, env, _sv1);
    S_i4i2i2_ p1 = pp1 ? *pp1 : S_i4i2i2_ {};

    typedef bool (*FuncToCall)(struct S_i4i2i2_ p0, struct S_i4i2i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsInternal(System.Guid) declare in Codice.CM.Common.InternalAttributes
bool w_bS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(System.Guid, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Guid, System.Guid) declare in System.Guid
bool w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsNullOrEmpty(UnityEngine.PropertyName) declare in UnityEngine.PropertyName
bool w_bS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Vector2Int, UnityEngine.Vector2Int) declare in UnityEngine.Vector2Int
bool w_bS_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4_S_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
    // JSValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4_ p0, struct S_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.AttachmentDescriptor, UnityEngine.Rendering.AttachmentDescriptor) declare in UnityEngine.Rendering.AttachmentDescriptor
bool w_bS_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_* pp0 = DataTransfer::GetPointer<S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_>(apis, env, _sv0);
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p0 = pp0 ? *pp0 : S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ {};
    // JSValToCSVal struct
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_* pp1 = DataTransfer::GetPointer<S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_>(apis, env, _sv1);
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p1 = pp1 ? *pp1 : S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p0, struct S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.int3) declare in Unity.Mathematics.math
bool w_bS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Threading.LockCookie, System.Threading.LockCookie) declare in System.Threading.LockCookie
bool w_bS_i4i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4_S_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4_ p0, struct S_i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.int4) declare in Unity.Mathematics.math
bool w_bS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.VertexAttributeDescriptor, UnityEngine.Rendering.VertexAttributeDescriptor) declare in UnityEngine.Rendering.VertexAttributeDescriptor
bool w_bS_i4i4i4i4_S_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4i4_ p0, struct S_i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryLayoutByRow(UnityEngine.RectInt, UInt32, UnityEngine.RectInt ByRef, UnityEngine.RectInt ByRef) declare in UnityEngine.Rendering.TileLayoutUtils
bool w_bS_i4i4i4i4_u4PS_i4i4i4i4_PS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4_u4PS_i4i4i4i4_PS_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_i4i4i4i4_* p2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4i4i4i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_i4i4i4i4_* p3 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4i4i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i4i4i4i4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_i4i4i4i4_ p0, uint32_t p1, struct S_i4i4i4i4_* p2, struct S_i4i4i4i4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryLayoutByTiles(UnityEngine.RectInt, UInt32, UnityEngine.RectInt ByRef, UnityEngine.RectInt ByRef, UnityEngine.RectInt ByRef, UnityEngine.RectInt ByRef) declare in UnityEngine.Rendering.TileLayoutUtils
bool w_bS_i4i4i4i4_u4PS_i4i4i4i4_PS_i4i4i4i4_PS_i4i4i4i4_PS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4_u4PS_i4i4i4i4_PS_i4i4i4i4_PS_i4i4i4i4_PS_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_i4i4i4i4_* p2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4i4i4i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_i4i4i4i4_* p3 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4i4i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i4i4i4i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    S_i4i4i4i4_* p4 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_i4i4i4i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_i4i4i4i4_));
        p4 = &up4;
    }
        
    // JSValToCSVal Pstruct
    S_i4i4i4i4_* p5 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, apis->unboxing(env, _sv5)); // valuetype ref
    S_i4i4i4i4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(S_i4i4i4i4_));
        p5 = &up5;
    }
        

    typedef bool (*FuncToCall)(struct S_i4i4i4i4_ p0, uint32_t p1, struct S_i4i4i4i4_* p2, struct S_i4i4i4i4_* p3, struct S_i4i4i4i4_* p4, struct S_i4i4i4i4_* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
            
    if (p5 == &up5)
    {
        apis->update_boxed_value(env, _sv5, DataTransfer::CopyValueType(apis, env, *p5, TIp5));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Reset(UnityEngine.AudioConfiguration) declare in UnityEngine.AudioSettings
bool w_bS_i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Reflection.Emit.ExceptionHandler, System.Reflection.Emit.ExceptionHandler) declare in System.Reflection.Emit.ExceptionHandler
bool w_bS_i4i4i4i4i4i4i4_S_i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4i4i4i4_S_i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4i4i4i4i4_ p0, struct S_i4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(System.Decimal) declare in System.Convert
bool w_bS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(System.Decimal, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bS_i4i4i4i4u8_S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Decimal, System.Decimal) declare in System.Decimal
bool w_bS_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
    // JSValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p0, struct S_i4i4i4i4u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.RenderTargetIdentifier
bool w_bS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_i4i4i4pi4i4i4_ p0, struct S_i4i4i4pi4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RasterState, UnityEngine.Rendering.RasterState) declare in UnityEngine.Rendering.RasterState
bool w_bS_i4i4r4u1u1u1u1_S_i4i4r4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4r4u1u1u1u1_S_i4i4r4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4i4r4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i4r4u1u1u1u1_>(apis, env, _sv0);
    S_i4i4r4u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i4r4u1u1u1u1_ {};
    // JSValToCSVal struct
    S_i4i4r4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i4r4u1u1u1u1_>(apis, env, _sv1);
    S_i4i4r4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i4r4u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct S_i4i4r4u1u1u1u1_ p0, struct S_i4i4r4u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_LessThan(System.Numerics.BigInteger, System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_bS_i4o_S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4o_S_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};

    typedef bool (*FuncToCall)(struct S_i4o_ p0, struct S_i4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_LessThan(System.Numerics.BigInteger, Int64) declare in System.Numerics.BigInteger
bool w_bS_i4o_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4o_i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4o_ p0, int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_LessThan(System.Numerics.BigInteger, UInt64) declare in System.Numerics.BigInteger
bool w_bS_i4o_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4o_u8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_i4o_* pp0 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv0);
    S_i4o_ p0 = pp0 ? *pp0 : S_i4o_ {};
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4o_ p0, uint64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Presets.PresetType, UnityEditor.Presets.PresetType) declare in UnityEditor.Presets.PresetType
bool w_bS_i4os_S_i4os_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4os_S_i4os_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4os_* pp0 = DataTransfer::GetPointer<S_i4os_>(apis, env, _sv0);
    S_i4os_ p0 = pp0 ? *pp0 : S_i4os_ {};
    // JSValToCSVal struct
    S_i4os_* pp1 = DataTransfer::GetPointer<S_i4os_>(apis, env, _sv1);
    S_i4os_ p1 = pp1 ? *pp1 : S_i4os_ {};

    typedef bool (*FuncToCall)(struct S_i4os_ p0, struct S_i4os_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SetDefaultPresetsForType(UnityEditor.Presets.PresetType, UnityEditor.Presets.DefaultPreset[]) declare in UnityEditor.Presets.Preset
bool w_bS_i4os_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4os_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_i4os_* pp0 = DataTransfer::GetPointer<S_i4os_>(apis, env, _sv0);
    S_i4os_ p0 = pp0 ? *pp0 : S_i4os_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_i4os_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsNullOrEmpty(UnityEngine.UIElements.StylePropertyName) declare in UnityEngine.UIElements.StylePropertyName
bool w_bS_i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4s_* pp0 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv0);
    S_i4s_ p0 = pp0 ? *pp0 : S_i4s_ {};

    typedef bool (*FuncToCall)(struct S_i4s_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StylePropertyName, UnityEngine.UIElements.StylePropertyName) declare in UnityEngine.UIElements.StylePropertyName
bool w_bS_i4s_S_i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4s_S_i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i4s_* pp0 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv0);
    S_i4s_ p0 = pp0 ? *pp0 : S_i4s_ {};
    // JSValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(apis, env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};

    typedef bool (*FuncToCall)(struct S_i4s_ p0, struct S_i4s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(System.TimeSpan, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bS_i8_S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_i8_ p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.TimeSpan, System.TimeSpan) declare in System.TimeSpan
bool w_bS_i8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8_S_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef bool (*FuncToCall)(struct S_i8_ p0, struct S_i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.TimerState, UnityEngine.UIElements.TimerState) declare in UnityEngine.UIElements.TimerState
bool w_bS_i8i8_S_i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8i8_S_i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8i8_* pp0 = DataTransfer::GetPointer<S_i8i8_>(apis, env, _sv0);
    S_i8i8_ p0 = pp0 ? *pp0 : S_i8i8_ {};
    // JSValToCSVal struct
    S_i8i8_* pp1 = DataTransfer::GetPointer<S_i8i8_>(apis, env, _sv1);
    S_i8i8_ p1 = pp1 ? *pp1 : S_i8i8_ {};

    typedef bool (*FuncToCall)(struct S_i8i8_ p0, struct S_i8i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Diagnostics.CounterSample, System.Diagnostics.CounterSample) declare in System.Diagnostics.CounterSample
bool w_bS_i8i8i8i8i8i8i8i4_S_i8i8i8i8i8i8i8i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8i8i8i8i8i8i8i4_S_i8i8i8i8i8i8i8i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp0 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(apis, env, _sv0);
    S_i8i8i8i8i8i8i8i4_ p0 = pp0 ? *pp0 : S_i8i8i8i8i8i8i8i4_ {};
    // JSValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp1 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(apis, env, _sv1);
    S_i8i8i8i8i8i8i8i4_ p1 = pp1 ? *pp1 : S_i8i8i8i8i8i8i8i4_ {};

    typedef bool (*FuncToCall)(struct S_i8i8i8i8i8i8i8i4_ p0, struct S_i8i8i8i8i8i8i8i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Reflection.CustomAttributeTypedArgument, System.Reflection.CustomAttributeTypedArgument) declare in System.Reflection.CustomAttributeTypedArgument
bool w_bS_oO_S_oO_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oO_S_oO_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oO_* pp0 = DataTransfer::GetPointer<S_oO_>(apis, env, _sv0);
    S_oO_ p0 = pp0 ? *pp0 : S_oO_ {};
    // JSValToCSVal struct
    S_oO_* pp1 = DataTransfer::GetPointer<S_oO_>(apis, env, _sv1);
    S_oO_ p1 = pp1 ? *pp1 : S_oO_ {};

    typedef bool (*FuncToCall)(struct S_oO_ p0, struct S_oO_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Diagnostics.ActivityLink, System.Diagnostics.ActivityLink) declare in System.Diagnostics.ActivityLink
bool w_bS_oS_S_s_S_s_i4sb__S_oS_S_s_S_s_i4sb__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oS_S_s_S_s_i4sb__S_oS_S_s_S_s_i4sb__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_S_s_S_s_i4sb__* pp0 = DataTransfer::GetPointer<S_oS_S_s_S_s_i4sb__>(apis, env, _sv0);
    S_oS_S_s_S_s_i4sb__ p0 = pp0 ? *pp0 : S_oS_S_s_S_s_i4sb__ {};
    // JSValToCSVal struct
    S_oS_S_s_S_s_i4sb__* pp1 = DataTransfer::GetPointer<S_oS_S_s_S_s_i4sb__>(apis, env, _sv1);
    S_oS_S_s_S_s_i4sb__ p1 = pp1 ? *pp1 : S_oS_S_s_S_s_i4sb__ {};

    typedef bool (*FuncToCall)(struct S_oS_S_s_S_s_i4sb__ p0, struct S_oS_S_s_S_s_i4sb__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Threading.CancellationTokenRegistration, System.Threading.CancellationTokenRegistration) declare in System.Threading.CancellationTokenRegistration
bool w_bS_oS_oi4__S_oS_oi4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oS_oi4__S_oS_oi4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_oi4__* pp0 = DataTransfer::GetPointer<S_oS_oi4__>(apis, env, _sv0);
    S_oS_oi4__ p0 = pp0 ? *pp0 : S_oS_oi4__ {};
    // JSValToCSVal struct
    S_oS_oi4__* pp1 = DataTransfer::GetPointer<S_oS_oi4__>(apis, env, _sv1);
    S_oS_oi4__ p1 = pp1 ? *pp1 : S_oS_oi4__ {};

    typedef bool (*FuncToCall)(struct S_oS_oi4__ p0, struct S_oS_oi4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.Cursor, UnityEngine.UIElements.Cursor) declare in UnityEngine.UIElements.Cursor
bool w_bS_oS_r4r4_i4_S_oS_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oS_r4r4_i4_S_oS_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oS_r4r4_i4_* pp0 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(apis, env, _sv0);
    S_oS_r4r4_i4_ p0 = pp0 ? *pp0 : S_oS_r4r4_i4_ {};
    // JSValToCSVal struct
    S_oS_r4r4_i4_* pp1 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(apis, env, _sv1);
    S_oS_r4r4_i4_ p1 = pp1 ? *pp1 : S_oS_r4r4_i4_ {};

    typedef bool (*FuncToCall)(struct S_oS_r4r4_i4_ p0, struct S_oS_r4r4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Threading.CancellationToken, System.Threading.CancellationToken) declare in System.Threading.CancellationToken
bool w_bS_o_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_o_S_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
    // JSValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(apis, env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};

    typedef bool (*FuncToCall)(struct S_o_ p0, struct S_o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Timeline.ClipDrawOptions, UnityEditor.Timeline.ClipDrawOptions) declare in UnityEditor.Timeline.ClipDrawOptions
bool w_bS_obsbsS_r4r4r4r4__S_obsbsS_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_obsbsS_r4r4r4r4__S_obsbsS_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_obsbsS_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_obsbsS_r4r4r4r4__>(apis, env, _sv0);
    S_obsbsS_r4r4r4r4__ p0 = pp0 ? *pp0 : S_obsbsS_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_obsbsS_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_obsbsS_r4r4r4r4__>(apis, env, _sv1);
    S_obsbsS_r4r4r4r4__ p1 = pp1 ? *pp1 : S_obsbsS_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_obsbsS_r4r4r4r4__ p0, struct S_obsbsS_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.StyleFont, UnityEngine.UIElements.StyleFont) declare in UnityEngine.UIElements.StyleFont
bool w_bS_oi4_S_oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oi4_S_oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oi4_* pp0 = DataTransfer::GetPointer<S_oi4_>(apis, env, _sv0);
    S_oi4_ p0 = pp0 ? *pp0 : S_oi4_ {};
    // JSValToCSVal struct
    S_oi4_* pp1 = DataTransfer::GetPointer<S_oi4_>(apis, env, _sv1);
    S_oi4_ p1 = pp1 ? *pp1 : S_oi4_ {};

    typedef bool (*FuncToCall)(struct S_oi4_ p0, struct S_oi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.FontDefinition, UnityEngine.UIElements.FontDefinition) declare in UnityEngine.UIElements.FontDefinition
bool w_bS_oo_S_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oo_S_oo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};
    // JSValToCSVal struct
    S_oo_* pp1 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv1);
    S_oo_ p1 = pp1 ? *pp1 : S_oo_ {};

    typedef bool (*FuncToCall)(struct S_oo_ p0, struct S_oo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Timeline.SequenceContext, UnityEditor.Timeline.SequenceContext) declare in UnityEditor.Timeline.SequenceContext
bool w_bS_oob_S_oob_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oob_S_oob_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oob_* pp0 = DataTransfer::GetPointer<S_oob_>(apis, env, _sv0);
    S_oob_ p0 = pp0 ? *pp0 : S_oob_ {};
    // JSValToCSVal struct
    S_oob_* pp1 = DataTransfer::GetPointer<S_oob_>(apis, env, _sv1);
    S_oob_ p1 = pp1 ? *pp1 : S_oob_ {};

    typedef bool (*FuncToCall)(struct S_oob_ p0, struct S_oob_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.UIElements.Background, UnityEngine.UIElements.Background) declare in UnityEngine.UIElements.Background
bool w_bS_oooo_S_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oooo_S_oooo_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_oooo_* pp0 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv0);
    S_oooo_ p0 = pp0 ? *pp0 : S_oooo_ {};
    // JSValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(apis, env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};

    typedef bool (*FuncToCall)(struct S_oooo_ p0, struct S_oooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.CullingResults) declare in UnityEngine.Rendering.CullingResults
bool w_bS_pPvS_pi4i4__S_pPvS_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pPvS_pi4i4__S_pPvS_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv0);
    S_pPvS_pi4i4__ p0 = pp0 ? *pp0 : S_pPvS_pi4i4__ {};
    // JSValToCSVal struct
    S_pPvS_pi4i4__* pp1 = DataTransfer::GetPointer<S_pPvS_pi4i4__>(apis, env, _sv1);
    S_pPvS_pi4i4__ p1 = pp1 ? *pp1 : S_pPvS_pi4i4__ {};

    typedef bool (*FuncToCall)(struct S_pPvS_pi4i4__ p0, struct S_pPvS_pi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Rendering.ScriptableRenderContext) declare in UnityEngine.Rendering.ScriptableRenderContext
bool w_bS_pS_pi4i4__S_pS_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pS_pi4i4__S_pS_pi4i4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pS_pi4i4__* pp0 = DataTransfer::GetPointer<S_pS_pi4i4__>(apis, env, _sv0);
    S_pS_pi4i4__ p0 = pp0 ? *pp0 : S_pS_pi4i4__ {};
    // JSValToCSVal struct
    S_pS_pi4i4__* pp1 = DataTransfer::GetPointer<S_pS_pi4i4__>(apis, env, _sv1);
    S_pS_pi4i4__ p1 = pp1 ? *pp1 : S_pS_pi4i4__ {};

    typedef bool (*FuncToCall)(struct S_pS_pi4i4__ p0, struct S_pS_pi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.RuntimeTypeHandle, System.Object) declare in System.RuntimeTypeHandle
bool w_bS_p_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_p_O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_p_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.ModuleHandle, System.ModuleHandle) declare in System.ModuleHandle
bool w_bS_p_S_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_p_S_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
    // JSValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(apis, env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};

    typedef bool (*FuncToCall)(struct S_p_ p0, struct S_p_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsTempMemoryHandle(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) declare in Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
bool w_bS_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};

    typedef bool (*FuncToCall)(struct S_pi4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsShaderVariantValid(UnityEngine.Rendering.ShaderKeywordSet, Boolean) declare in UnityEngine.Rendering.HDROutputUtils
bool w_bS_pppu8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pppu8_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_pppu8_* pp0 = DataTransfer::GetPointer<S_pppu8_>(apis, env, _sv0);
    S_pppu8_ p0 = pp0 ? *pp0 : S_pppu8_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_pppu8_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Playables.PlayableHandle, UnityEngine.Playables.PlayableHandle) declare in UnityEngine.Playables.PlayableHandle
bool w_bS_pu4_S_pu4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pu4_S_pu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_pu4_* pp0 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv0);
    S_pu4_ p0 = pp0 ? *pp0 : S_pu4_ {};
    // JSValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(apis, env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};

    typedef bool (*FuncToCall)(struct S_pu4_ p0, struct S_pu4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.BoneWeight1, UnityEngine.BoneWeight1) declare in UnityEngine.BoneWeight1
bool w_bS_r4i4_S_r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4i4_S_r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4i4_* pp0 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv0);
    S_r4i4_ p0 = pp0 ? *pp0 : S_r4i4_ {};
    // JSValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(apis, env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};

    typedef bool (*FuncToCall)(struct S_r4i4_ p0, struct S_r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.float2) declare in Unity.Mathematics.math
bool w_bS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Vector3 ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PlaceObject(UnityEngine.Vector2, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_PS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_PS_r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4_* p1, struct S_r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Vector3 ByRef, UnityEngine.GameObject ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_PS_r4r4r4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_PS_r4r4r4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4r4_* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_bS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, struct S_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Show(UnityEngine.Vector2, IProvider) declare in UnityEditor.Rendering.FilterWindow
bool w_bS_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Vector3 ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_oPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_oPS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Vector3 ByRef, UnityEngine.GameObject ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_oPS_r4r4r4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_oPS_r4r4r4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, struct S_r4r4r4_* p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Transform[], UnityEngine.Vector3 ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_ooPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_ooPS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Transform[], UnityEngine.Vector3 ByRef, UnityEngine.GameObject ByRef) declare in UnityEditor.HandleUtility
bool w_bS_r4r4_ooPS_r4r4r4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_ooPS_r4r4r4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4_));
        p3 = &up3;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ref
    Il2CppObject** p4 = &up4;
        

    typedef bool (*FuncToCall)(struct S_r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_* p3, Il2CppObject** p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
            
    apis->update_boxed_value(env, _sv4, CSRefToJsValue(apis, env, TIp4, *p4));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.float3) declare in Unity.Mathematics.math
bool w_bS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindClosestEdge(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, UnityEngine.AI.NavMeshQueryFilter) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal struct
    S_oi4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4_>(apis, env, _sv2);
    S_oi4i4_ p2 = pp2 ? *pp2 : S_oi4i4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1, struct S_oi4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindClosestEdge(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Int32) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SamplePosition(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Single, UnityEngine.AI.NavMeshQueryFilter) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4S_oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4S_oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_oi4i4_* pp3 = DataTransfer::GetPointer<S_oi4i4_>(apis, env, _sv3);
    S_oi4i4_ p3 = pp3 ? *pp3 : S_oi4i4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1, float p2, struct S_oi4i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SamplePosition(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Single, Int32) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_bS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, UnityEngine.AI.NavMeshQueryFilter) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal struct
    S_oi4i4_* pp3 = DataTransfer::GetPointer<S_oi4i4_>(apis, env, _sv3);
    S_oi4i4_ p3 = pp3 ? *pp3 : S_oi4i4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2, struct S_oi4i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Int32) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CalculatePath(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.AI.NavMeshQueryFilter, UnityEngine.AI.NavMeshPath) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_S_r4r4r4_S_oi4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_oi4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_oi4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4_>(apis, env, _sv2);
    S_oi4i4_ p2 = pp2 ? *pp2 : S_oi4i4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_oi4i4_ p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, struct S_r4r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, struct S_r4r4r4r4_ p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, struct S_r4r4r4r4_ p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, struct S_r4r4r4r4_ p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CalculatePath(UnityEngine.Vector3, UnityEngine.Vector3, Int32, UnityEngine.AI.NavMeshPath) declare in UnityEngine.AI.NavMesh
bool w_bS_r4r4r4_S_r4r4r4_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p4 = &up4;
    }
        
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p4 = &up4;
    }
        
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p4 = &up4;
    }
        
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_S_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4_ p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Vector3, UnityEngine.Quaternion, Single, Single, CapFunction) declare in UnityEditor.Handles
bool w_bS_r4r4r4_S_r4r4r4r4_r4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4r4_r4r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, struct S_r4r4r4r4_ p1, float p2, float p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckSphere(UnityEngine.Vector3, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_));
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckSphere(UnityEngine.Vector3, Single, Int32) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckSphere(UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction) declare in UnityEngine.Physics
bool w_bS_r4r4r4_r4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4_ p0, float p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsViewportRectValidToRender(UnityEngine.Rect) declare in UnityEditor.CameraEditorUtils
bool w_bS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IntersectsSegment(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEditor.Experimental.GraphView.RectUtils
bool w_bS_r4r4r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_S_r4r4_S_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Inequality(UnityEngine.Rect, UnityEngine.Rect) declare in UnityEngine.Rect
bool w_bS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, struct S_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, Boolean) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, Boolean, UnityEngine.Texture) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BeginFoldoutHeaderGroup(UnityEngine.Rect, Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_boDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_boDoDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean InspectorTitlebar(UnityEngine.Rect, Boolean, UnityEngine.Object, Boolean) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_bob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(UnityEngine.Rect, Boolean, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_bobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bobo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, Boolean, UnityEngine.Texture, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_boo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, Boolean, System.String) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_bs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BeginFoldoutHeaderGroup(UnityEngine.Rect, Boolean, System.String, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_bsDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bsDoDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(UnityEngine.Rect, Boolean, System.String, Boolean) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_bsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bsb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppString* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(UnityEngine.Rect, Boolean, System.String, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_bsbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bsbo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, Boolean, System.String, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_bso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, bool p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, Int32, Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_i4boo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_i4boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, int32_t p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Rect, UnityEngine.Texture) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, UnityEngine.GUIContent, Boolean) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_ob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_obo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_obo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DropdownButton(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.FocusType) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DropdownButton(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_oi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PropertyField(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent, Boolean) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ScrollTowards(UnityEngine.Rect, Single) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Rect, System.String) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, System.String, Boolean) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_sb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.Rect, System.String, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUI
bool w_bS_r4r4r4r4_sbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_sbo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Rect, System.String, UnityEngine.GUIStyle) declare in UnityEngine.GUI
bool w_bS_r4r4r4r4_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.BoneWeight, UnityEngine.BoneWeight) declare in UnityEngine.BoneWeight
bool w_bS_r4r4r4r4i4i4i4i4_S_r4r4r4r4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4i4i4i4i4_S_r4r4r4r4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4i4i4i4i4_>(apis, env, _sv0);
    S_r4r4r4r4i4i4i4i4_ p0 = pp0 ? *pp0 : S_r4r4r4r4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4i4i4i4_>(apis, env, _sv1);
    S_r4r4r4r4i4i4i4i4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4i4i4i4i4_ p0, struct S_r4r4r4r4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.TextCore.GlyphMetrics, UnityEngine.TextCore.GlyphMetrics) declare in UnityEngine.TextCore.GlyphMetrics
bool w_bS_r4r4r4r4r4_S_r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4_S_r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4_ p0, struct S_r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Invert(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2 ByRef) declare in System.Numerics.Matrix3x2
bool w_bS_r4r4r4r4r4r4_PS_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4_PS_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4r4r4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2) declare in System.Numerics.Matrix3x2
bool w_bS_r4r4r4r4r4r4_S_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Decompose(System.Numerics.Matrix4x4, System.Numerics.Vector3 ByRef, System.Numerics.Quaternion ByRef, System.Numerics.Vector3 ByRef) declare in System.Numerics.Matrix4x4
bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_r4r4r4r4_));
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4_* p1, struct S_r4r4r4r4_* p2, struct S_r4r4r4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
            
    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Inverse3DAffine(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4 ByRef) declare in UnityEngine.Matrix4x4
bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Matrix4x4
bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Rendering.SphericalHarmonicsL2) declare in UnityEngine.Rendering.SphericalHarmonicsL2
bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.double2) declare in Unity.Mathematics.math
bool w_bS_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};

    typedef bool (*FuncToCall)(struct S_r8r8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Numerics.Complex, System.Numerics.Complex) declare in System.Numerics.Complex
bool w_bS_r8r8_S_r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r8r8_S_r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv0);
    S_r8r8_ p0 = pp0 ? *pp0 : S_r8r8_ {};
    // JSValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(apis, env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};

    typedef bool (*FuncToCall)(struct S_r8r8_ p0, struct S_r8r8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.double3) declare in Unity.Mathematics.math
bool w_bS_r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8_>(apis, env, _sv0);
    S_r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8_ {};

    typedef bool (*FuncToCall)(struct S_r8r8r8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.double4) declare in Unity.Mathematics.math
bool w_bS_r8r8r8r8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r8r8r8r8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_r8r8r8r8_* pp0 = DataTransfer::GetPointer<S_r8r8r8r8_>(apis, env, _sv0);
    S_r8r8r8r8_ p0 = pp0 ? *pp0 : S_r8r8r8r8_ {};

    typedef bool (*FuncToCall)(struct S_r8r8r8r8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Timeline.TrackDrawOptions, UnityEditor.Timeline.TrackDrawOptions) declare in UnityEditor.Timeline.TrackDrawOptions
bool w_bS_sS_r4r4r4r4_r4o_S_sS_r4r4r4r4_r4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sS_r4r4r4r4_r4o_S_sS_r4r4r4r4_r4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sS_r4r4r4r4_r4o_* pp0 = DataTransfer::GetPointer<S_sS_r4r4r4r4_r4o_>(apis, env, _sv0);
    S_sS_r4r4r4r4_r4o_ p0 = pp0 ? *pp0 : S_sS_r4r4r4r4_r4o_ {};
    // JSValToCSVal struct
    S_sS_r4r4r4r4_r4o_* pp1 = DataTransfer::GetPointer<S_sS_r4r4r4r4_r4o_>(apis, env, _sv1);
    S_sS_r4r4r4r4_r4o_ p1 = pp1 ? *pp1 : S_sS_r4r4r4r4_r4o_ {};

    typedef bool (*FuncToCall)(struct S_sS_r4r4r4r4_r4o_ p0, struct S_sS_r4r4r4r4_r4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsVersionCached(UnityEngine.CachedAssetBundle) declare in UnityEngine.Caching
bool w_bS_sS_u8u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sS_u8u8__");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sS_u8u8__* pp0 = DataTransfer::GetPointer<S_sS_u8u8__>(apis, env, _sv0);
    S_sS_u8u8__ p0 = pp0 ? *pp0 : S_sS_u8u8__ {};

    typedef bool (*FuncToCall)(struct S_sS_u8u8__ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsOSPlatform(System.Runtime.InteropServices.OSPlatform) declare in System.Runtime.InteropServices.RuntimeInformation
bool w_bS_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};

    typedef bool (*FuncToCall)(struct S_s_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.HashAlgorithmName) declare in System.Security.Cryptography.HashAlgorithmName
bool w_bS_s_S_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_s_S_s_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(apis, env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};

    typedef bool (*FuncToCall)(struct S_s_ p0, struct S_s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SwitchActiveBuildTarget(UnityEditor.Build.NamedBuildTarget, UnityEditor.BuildTarget) declare in UnityEditor.EditorUserBuildSettings
bool w_bS_s_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_s_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_s_* pp0 = DataTransfer::GetPointer<S_s_>(apis, env, _sv0);
    S_s_ p0 = pp0 ? *pp0 : S_s_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_s_ p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.MPE.ChannelInfo, UnityEditor.MPE.ChannelInfo) declare in UnityEditor.MPE.ChannelInfo
bool w_bS_si4_S_si4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4_S_si4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4_* pp0 = DataTransfer::GetPointer<S_si4_>(apis, env, _sv0);
    S_si4_ p0 = pp0 ? *pp0 : S_si4_ {};
    // JSValToCSVal struct
    S_si4_* pp1 = DataTransfer::GetPointer<S_si4_>(apis, env, _sv1);
    S_si4_ p1 = pp1 ? *pp1 : S_si4_ {};

    typedef bool (*FuncToCall)(struct S_si4_ p0, struct S_si4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Implicit(UnityEditor.Search.StringView) declare in UnityEditor.Search.StringView
bool w_bS_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};

    typedef bool (*FuncToCall)(struct S_si4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.MPE.ChannelClientInfo, UnityEditor.MPE.ChannelClientInfo) declare in UnityEditor.MPE.ChannelClientInfo
bool w_bS_si4i4_S_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_S_si4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};
    // JSValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};

    typedef bool (*FuncToCall)(struct S_si4i4_ p0, struct S_si4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(Microsoft.Extensions.Primitives.StringSegment, Microsoft.Extensions.Primitives.StringSegment, System.StringComparison) declare in Microsoft.Extensions.Primitives.StringSegment
bool w_bS_si4i4_S_si4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_S_si4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};
    // JSValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(struct S_si4i4_ p0, struct S_si4i4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Search.StringView, System.String) declare in UnityEditor.Search.StringView
bool w_bS_si4i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_si4i4_* pp0 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv0);
    S_si4i4_ p0 = pp0 ? *pp0 : S_si4i4_ {};
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(struct S_si4i4_ p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Security.Cryptography.CngProperty, System.Security.Cryptography.CngProperty) declare in System.Security.Cryptography.CngProperty
bool w_bS_si4oN_bi4__S_si4oN_bi4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4oN_bi4__S_si4oN_bi4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_si4oN_bi4__* pp0 = DataTransfer::GetPointer<S_si4oN_bi4__>(apis, env, _sv0);
    S_si4oN_bi4__ p0 = pp0 ? *pp0 : S_si4oN_bi4__ {};
    // JSValToCSVal struct
    S_si4oN_bi4__* pp1 = DataTransfer::GetPointer<S_si4oN_bi4__>(apis, env, _sv1);
    S_si4oN_bi4__ p1 = pp1 ? *pp1 : S_si4oN_bi4__ {};

    typedef bool (*FuncToCall)(struct S_si4oN_bi4__ p0, struct S_si4oN_bi4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.EditorCurveBinding, UnityEditor.EditorCurveBinding) declare in UnityEditor.EditorCurveBinding
bool w_bS_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_sosi4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_sosi4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p0, struct S_sosi4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.Experimental.AssetMoveInfo, UnityEditor.Experimental.AssetMoveInfo) declare in UnityEditor.Experimental.AssetMoveInfo
bool w_bS_ss_S_ss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_ss_S_ss_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_ss_* pp0 = DataTransfer::GetPointer<S_ss_>(apis, env, _sv0);
    S_ss_ p0 = pp0 ? *pp0 : S_ss_ {};
    // JSValToCSVal struct
    S_ss_* pp1 = DataTransfer::GetPointer<S_ss_>(apis, env, _sv1);
    S_ss_ p1 = pp1 ? *pp1 : S_ss_ {};

    typedef bool (*FuncToCall)(struct S_ss_ p0, struct S_ss_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.ShaderMessage, UnityEditor.ShaderMessage) declare in UnityEditor.ShaderMessage
bool w_bS_sssi4i4i4_S_sssi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sssi4i4i4_S_sssi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_sssi4i4i4_* pp0 = DataTransfer::GetPointer<S_sssi4i4i4_>(apis, env, _sv0);
    S_sssi4i4i4_ p0 = pp0 ? *pp0 : S_sssi4i4i4_ {};
    // JSValToCSVal struct
    S_sssi4i4i4_* pp1 = DataTransfer::GetPointer<S_sssi4i4i4_>(apis, env, _sv1);
    S_sssi4i4i4_ p1 = pp1 ? *pp1 : S_sssi4i4i4_ {};

    typedef bool (*FuncToCall)(struct S_sssi4i4i4_ p0, struct S_sssi4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.InputFeatureUsage, UnityEngine.XR.InputFeatureUsage) declare in UnityEngine.XR.InputFeatureUsage
bool w_bS_su4_S_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_su4_S_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_su4_* pp0 = DataTransfer::GetPointer<S_su4_>(apis, env, _sv0);
    S_su4_ p0 = pp0 ? *pp0 : S_su4_ {};
    // JSValToCSVal struct
    S_su4_* pp1 = DataTransfer::GetPointer<S_su4_>(apis, env, _sv1);
    S_su4_ p1 = pp1 ? *pp1 : S_su4_ {};

    typedef bool (*FuncToCall)(struct S_su4_ p0, struct S_su4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsKeywordLocal(UnityEngine.Rendering.ShaderKeyword) declare in UnityEngine.Rendering.ShaderKeyword
bool w_bS_su4bbb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_su4bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_su4bbb_* pp0 = DataTransfer::GetPointer<S_su4bbb_>(apis, env, _sv0);
    S_su4bbb_ p0 = pp0 ? *pp0 : S_su4bbb_ {};

    typedef bool (*FuncToCall)(struct S_su4bbb_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Explicit(System.Data.SqlTypes.SqlBoolean) declare in System.Data.SqlTypes.SqlBoolean
bool w_bS_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};

    typedef bool (*FuncToCall)(struct S_u1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.BitArray8, UnityEngine.Rendering.BitArray8) declare in UnityEngine.Rendering.BitArray8
bool w_bS_u1_S_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1_S_u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1_* pp0 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv0);
    S_u1_ p0 = pp0 ? *pp0 : S_u1_ {};
    // JSValToCSVal struct
    S_u1_* pp1 = DataTransfer::GetPointer<S_u1_>(apis, env, _sv1);
    S_u1_ p1 = pp1 ? *pp1 : S_u1_ {};

    typedef bool (*FuncToCall)(struct S_u1_ p0, struct S_u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.DepthState, UnityEngine.Rendering.DepthState) declare in UnityEngine.Rendering.DepthState
bool w_bS_u1i1_S_u1i1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1i1_S_u1i1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1i1_* pp0 = DataTransfer::GetPointer<S_u1i1_>(apis, env, _sv0);
    S_u1i1_ p0 = pp0 ? *pp0 : S_u1i1_ {};
    // JSValToCSVal struct
    S_u1i1_* pp1 = DataTransfer::GetPointer<S_u1i1_>(apis, env, _sv1);
    S_u1i1_ p1 = pp1 ? *pp1 : S_u1i1_ {};

    typedef bool (*FuncToCall)(struct S_u1i1_ p0, struct S_u1i1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Buffers.StandardFormat, System.Buffers.StandardFormat) declare in System.Buffers.StandardFormat
bool w_bS_u1u1_S_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1_S_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1_>(apis, env, _sv0);
    S_u1u1_ p0 = pp0 ? *pp0 : S_u1u1_ {};
    // JSValToCSVal struct
    S_u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1_>(apis, env, _sv1);
    S_u1u1_ p1 = pp1 ? *pp1 : S_u1u1_ {};

    typedef bool (*FuncToCall)(struct S_u1u1_ p0, struct S_u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TakesSingleByteArgument(System.Reflection.Emit.OpCode) declare in System.Reflection.Emit.OpCodes
bool w_bS_u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Reflection.Emit.OpCode, System.Reflection.Emit.OpCode) declare in System.Reflection.Emit.OpCode
bool w_bS_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p0, struct S_u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.StencilState, UnityEngine.Rendering.StencilState) declare in UnityEngine.Rendering.StencilState
bool w_bS_u1u1u1u1u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_u1u1u1u1u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ p0, struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsCategoryEnabled(Unity.Profiling.ProfilerCategory) declare in UnityEngine.Profiling.Profiler
bool w_bS_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};

    typedef bool (*FuncToCall)(struct S_u2_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.BitArray16, UnityEngine.Rendering.BitArray16) declare in UnityEngine.Rendering.BitArray16
bool w_bS_u2_S_u2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u2_S_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u2_* pp0 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv0);
    S_u2_ p0 = pp0 ? *pp0 : S_u2_ {};
    // JSValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(apis, env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};

    typedef bool (*FuncToCall)(struct S_u2_ p0, struct S_u2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord, UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord) declare in UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord
bool w_bS_u4S_r4r4r4r4__S_u4S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4S_r4r4r4r4__S_u4S_r4r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(apis, env, _sv0);
    S_u4S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_u4S_r4r4r4r4__ {};
    // JSValToCSVal struct
    S_u4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(apis, env, _sv1);
    S_u4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_u4S_r4r4r4r4__ {};

    typedef bool (*FuncToCall)(struct S_u4S_r4r4r4r4__ p0, struct S_u4S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.GraphicsBufferHandle, UnityEngine.GraphicsBufferHandle) declare in UnityEngine.GraphicsBufferHandle
bool w_bS_u4_S_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4_S_u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4_* pp0 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv0);
    S_u4_ p0 = pp0 ? *pp0 : S_u4_ {};
    // JSValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(apis, env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};

    typedef bool (*FuncToCall)(struct S_u4_ p0, struct S_u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.HapticCapabilities, UnityEngine.XR.HapticCapabilities) declare in UnityEngine.XR.HapticCapabilities
bool w_bS_u4bbu4u4u4_S_u4bbu4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4bbu4u4u4_S_u4bbu4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4bbu4u4u4_* pp0 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(apis, env, _sv0);
    S_u4bbu4u4u4_ p0 = pp0 ? *pp0 : S_u4bbu4u4u4_ {};
    // JSValToCSVal struct
    S_u4bbu4u4u4_* pp1 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(apis, env, _sv1);
    S_u4bbu4u4u4_ p1 = pp1 ? *pp1 : S_u4bbu4u4u4_ {};

    typedef bool (*FuncToCall)(struct S_u4bbu4u4u4_ p0, struct S_u4bbu4u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.uint2) declare in Unity.Mathematics.math
bool w_bS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};

    typedef bool (*FuncToCall)(struct S_u4u4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.PassIdentifier, UnityEngine.Rendering.PassIdentifier) declare in UnityEngine.Rendering.PassIdentifier
bool w_bS_u4u4_S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4_S_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
    // JSValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};

    typedef bool (*FuncToCall)(struct S_u4u4_ p0, struct S_u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.uint3) declare in Unity.Mathematics.math
bool w_bS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};

    typedef bool (*FuncToCall)(struct S_u4u4u4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean any(Unity.Mathematics.uint4) declare in Unity.Mathematics.math
bool w_bS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};

    typedef bool (*FuncToCall)(struct S_u4u4u4u4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEditor.GUID, UnityEditor.GUID) declare in UnityEditor.GUID
bool w_bS_u4u4u4u4_S_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u4u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv0);
    S_u4u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4u4_ {};
    // JSValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};

    typedef bool (*FuncToCall)(struct S_u4u4u4u4_ p0, struct S_u4u4u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_LessThan(UnityEditor.Search.PropertyDatabaseRecordKey, UnityEditor.Search.PropertyDatabaseRecordKey) declare in UnityEditor.Search.PropertyDatabaseRecordKey
bool w_bS_u8S_u8u8__S_u8S_u8u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8S_u8u8__S_u8S_u8u8__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8S_u8u8__* pp0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv0);
    S_u8S_u8u8__ p0 = pp0 ? *pp0 : S_u8S_u8u8__ {};
    // JSValToCSVal struct
    S_u8S_u8u8__* pp1 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, _sv1);
    S_u8S_u8u8__ p1 = pp1 ? *pp1 : S_u8S_u8u8__ {};

    typedef bool (*FuncToCall)(struct S_u8S_u8u8__ p0, struct S_u8S_u8u8__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(System.DateTime) declare in System.Convert
bool w_bS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};

    typedef bool (*FuncToCall)(struct S_u8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(System.DateTime, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bS_u8_S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(struct S_u8_ p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.DateTime, System.DateTime) declare in System.DateTime
bool w_bS_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_S_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};

    typedef bool (*FuncToCall)(struct S_u8_ p0, struct S_u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDaylightSavingTime(System.DateTime, System.Globalization.DaylightTime) declare in System.TimeZone
bool w_bS_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(struct S_u8_ p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.InputDevice, UnityEngine.XR.InputDevice) declare in UnityEngine.XR.InputDevice
bool w_bS_u8b_S_u8b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8b_S_u8b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8b_* pp0 = DataTransfer::GetPointer<S_u8b_>(apis, env, _sv0);
    S_u8b_ p0 = pp0 ? *pp0 : S_u8b_ {};
    // JSValToCSVal struct
    S_u8b_* pp1 = DataTransfer::GetPointer<S_u8b_>(apis, env, _sv1);
    S_u8b_ p1 = pp1 ? *pp1 : S_u8b_ {};

    typedef bool (*FuncToCall)(struct S_u8b_ p0, struct S_u8b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckFenceIsDependencyOrDidSyncFence(Unity.Jobs.JobHandle, Unity.Jobs.JobHandle) declare in Unity.Jobs.JobHandle
bool w_bS_u8i4i4p_S_u8i4i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8i4i4p_S_u8i4i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8i4i4p_* pp0 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv0);
    S_u8i4i4p_ p0 = pp0 ? *pp0 : S_u8i4i4p_ {};
    // JSValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(apis, env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};

    typedef bool (*FuncToCall)(struct S_u8i4i4p_ p0, struct S_u8i4i4p_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.XR.Hand, UnityEngine.XR.Hand) declare in UnityEngine.XR.Hand
bool w_bS_u8u4_S_u8u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u4_S_u8u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u4_* pp0 = DataTransfer::GetPointer<S_u8u4_>(apis, env, _sv0);
    S_u8u4_ p0 = pp0 ? *pp0 : S_u8u4_ {};
    // JSValToCSVal struct
    S_u8u4_* pp1 = DataTransfer::GetPointer<S_u8u4_>(apis, env, _sv1);
    S_u8u4_ p1 = pp1 ? *pp1 : S_u8u4_ {};

    typedef bool (*FuncToCall)(struct S_u8u4_ p0, struct S_u8u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetArtifactPaths(UnityEngine.Hash128, System.String[] ByRef) declare in UnityEditor.Experimental.AssetDatabaseExperimental
bool w_bS_u8u8_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(struct S_u8u8_ p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Hash128, UnityEngine.Hash128) declare in UnityEngine.Hash128
bool w_bS_u8u8_S_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8_S_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv0);
    S_u8u8_ p0 = pp0 ? *pp0 : S_u8u8_ {};
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};

    typedef bool (*FuncToCall)(struct S_u8u8_ p0, struct S_u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Mono.Unix.Native.Stat, Mono.Unix.Native.Stat) declare in Mono.Unix.Native.Stat
bool w_bS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* pp0 = DataTransfer::GetPointer<S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_>(apis, env, _sv0);
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ p0 = pp0 ? *pp0 : S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ {};
    // JSValToCSVal struct
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* pp1 = DataTransfer::GetPointer<S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_>(apis, env, _sv1);
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ p1 = pp1 ? *pp1 : S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ {};

    typedef bool (*FuncToCall)(struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ p0, struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.BitArray256, UnityEngine.Rendering.BitArray256) declare in UnityEngine.Rendering.BitArray256
bool w_bS_u8u8u8u8_S_u8u8u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8u8u8_S_u8u8u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8u8u8_>(apis, env, _sv0);
    S_u8u8u8u8_ p0 = pp0 ? *pp0 : S_u8u8u8u8_ {};
    // JSValToCSVal struct
    S_u8u8u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8u8u8_>(apis, env, _sv1);
    S_u8u8u8u8_ p1 = pp1 ? *pp1 : S_u8u8u8u8_ {};

    typedef bool (*FuncToCall)(struct S_u8u8u8u8_ p0, struct S_u8u8u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Mono.Unix.Native.Statvfs, Mono.Unix.Native.Statvfs) declare in Mono.Unix.Native.Statvfs
bool w_bS_u8u8u8u8u8u8u8u8u8u8u8_S_u8u8u8u8u8u8u8u8u8u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8u8u8u8u8u8u8u8u8u8_S_u8u8u8u8u8u8u8u8u8u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal struct
    S_u8u8u8u8u8u8u8u8u8u8u8_* pp0 = DataTransfer::GetPointer<S_u8u8u8u8u8u8u8u8u8u8u8_>(apis, env, _sv0);
    S_u8u8u8u8u8u8u8u8u8u8u8_ p0 = pp0 ? *pp0 : S_u8u8u8u8u8u8u8u8u8u8u8_ {};
    // JSValToCSVal struct
    S_u8u8u8u8u8u8u8u8u8u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8u8u8u8u8u8u8u8u8u8_>(apis, env, _sv1);
    S_u8u8u8u8u8u8u8u8u8u8u8_ p1 = pp1 ? *pp1 : S_u8u8u8u8u8u8u8u8u8u8u8_ {};

    typedef bool (*FuncToCall)(struct S_u8u8u8u8u8u8u8u8u8u8u8_ p0, struct S_u8u8u8u8u8u8u8u8u8u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Object) declare in System.Object
bool w_bTO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bTO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasField(System.Object, System.String) declare in FullscreenEditor.ReflectionUtility
bool w_bTs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bTs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(void*,Il2CppString* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasMethod(System.Object, System.String, System.Type[]) declare in FullscreenEditor.ReflectionUtility
bool w_bTsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bTsDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef bool (*FuncToCall)(void*,Il2CppString* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ProfilesAre(Codice.Client.Common.ServerProfile[]) declare in PlasticGui.TestProfilesConfig
bool w_bVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bVo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len < 0) return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false)) return false;
    }
    
    // JSValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, js_args_len, 0);
                

    typedef bool (*FuncToCall)(Il2CppArray* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Boolean) declare in System.Convert
bool w_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(Boolean, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bbS_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbS_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(bool p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_bbVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbVo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppArray* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean StartRecording(Boolean, Boolean) declare in UnityEngine.Apple.ReplayKit.ReplayKit
bool w_bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(bool p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, UnityEngine.GUIContent) declare in UnityEditor.EditorGUILayout
bool w_bbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToggleButton(Boolean, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in DG.DOTweenEditor.UI.EditorGUIUtils
bool w_bboDbDoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bboDbDoVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        auto TIp4_V = il2cpp::vm::Class::GetElementClass(TIp4);if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref params
    Il2CppArray* p4 = Params<void*>::PackRef(apis, env, info, TIp4, js_args_len, 4);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppArray* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BeginFoldoutHeaderGroup(Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle) declare in UnityEditor.EditorGUILayout
bool w_bboDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bboDoDoDo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(Boolean, UnityEngine.Texture, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_bboVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bboVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, UnityEngine.GUIContent, Boolean) declare in UnityEditor.EditorGUILayout
bool w_bbob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbob");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUILayout
bool w_bbobo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbobo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUILayout
bool w_bboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bboo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(Boolean, UnityEngine.Texture, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_bbooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbooVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, System.String) declare in UnityEditor.EditorGUILayout
bool w_bbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BeginFoldoutHeaderGroup(Boolean, System.String, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle) declare in UnityEditor.EditorGUILayout
bool w_bbsDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbsDoDoDo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(Boolean, System.String, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_bbsVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbsVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, System.String, Boolean) declare in UnityEditor.EditorGUILayout
bool w_bbsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbsb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, System.String, Boolean, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUILayout
bool w_bbsbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbsbo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Foldout(Boolean, System.String, UnityEngine.GUIStyle) declare in UnityEditor.EditorGUILayout
bool w_bbso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbso");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(Boolean, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_bbsoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bbsoVo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef bool (*FuncToCall)(bool p0, Il2CppString* p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDigit(Char) declare in System.Char
bool w_bc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(Il2CppChar p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsSurrogatePair(Char, Char) declare in System.Char
bool w_bcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bcc");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppChar p0, Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(SByte) declare in System.Convert
bool w_bi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(int8_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(SByte, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bi1S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi1S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(int8_t p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Int16) declare in System.Convert
bool w_bi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(int16_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFromLockType(Mono.Unix.Native.LockType, Int16 ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bi2Pi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi2Pi2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int16_t up1 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv1);
    int16_t* p1 = &up1;

    typedef bool (*FuncToCall)(int16_t p0, int16_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCompressUsingBufferPool(Codice.CM.Common.EnumCompressionType, Byte[] ByRef, Int32 ByRef, Codice.Utils.Buffers.FlexibleBufferPool) declare in Codice.CM.Common.Compression
bool w_bi2PoPi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi2PoPi4o");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(int16_t p0, Il2CppObject** p1, int32_t* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(Int16, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bi2S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi2S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(int16_t p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ContainsAny(Codice.CM.Common.MergeChangeType, Codice.CM.Common.MergeChangeType) declare in Codice.CM.Common.MergeChangeTypesOperator
bool w_bi2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi2i2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int16_t p0, int16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsCompressionNeeded(Codice.CM.Common.EnumCompressionType, Int32) declare in Codice.CM.Common.Compression
bool w_bi2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi2i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int16_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Int32) declare in System.Convert
bool w_bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetObjectIdentifier(Int32, UnityEditor.Build.Content.ObjectIdentifier ByRef) declare in UnityEditor.Build.Content.ObjectIdentifier
bool w_bi4PS_S_u4u4u4u4_i8i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PS_S_u4u4u4u4_i8i4s_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_u4u4u4u4_i8i4s_* p1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u4u4u4u4_i8i4s_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u4u4u4u4_i8i4s_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(int32_t p0, struct S_S_u4u4u4u4_i8i4s_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetColorSpaceForGamut(UnityEngine.ColorGamut, Int32 ByRef) declare in UnityEngine.Rendering.HDROutputUtils
bool w_bi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef bool (*FuncToCall)(int32_t p0, int32_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetFontAsset(Int32, TMPro.TMP_FontAsset ByRef) declare in TMPro.MaterialReferenceManager
bool w_bi4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4Po");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(int32_t p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGUIDAndLocalFileIdentifier(Int32, System.String ByRef, Int32 ByRef) declare in UnityEditor.AssetDatabase
bool w_bi4PsPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PsPi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(int32_t p0, Il2CppString** p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGUIDAndLocalFileIdentifier(Int32, System.String ByRef, Int64 ByRef) declare in UnityEditor.AssetDatabase
bool w_bi4PsPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PsPi8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;

    typedef bool (*FuncToCall)(int32_t p0, Il2CppString** p1, int64_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetAdditionalBakedProbes(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.SphericalHarmonicsL2], Unity.Collections.NativeArray`1[System.Single]) declare in UnityEditor.Experimental.Lightmapping
bool w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef bool (*FuncToCall)(int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetAdditionalBakedProbes(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.SphericalHarmonicsL2], Unity.Collections.NativeArray`1[System.Single], Unity.Collections.NativeArray`1[System.Single]) declare in UnityEditor.Experimental.Lightmapping
bool w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
    // JSValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};

    typedef bool (*FuncToCall)(int32_t p0, struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(Int32, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bi4S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(int32_t p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetAdditionalBakedProbes(Int32, System.Span`1[UnityEngine.Rendering.SphericalHarmonicsL2], System.Span`1[System.Single], System.Span`1[System.Single]) declare in UnityEditor.Experimental.Lightmapping
bool w_bi4S_S_p_i4_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_S_p_i4_S_S_p_i4_S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
    // JSValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};

    typedef bool (*FuncToCall)(int32_t p0, struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetDefaultCheckedValueForType(Codice.CM.Common.ChangeTypes, Boolean) declare in PlasticGui.WorkspaceWindow.PendingChanges.PendingChangesViewCheckedStateManager
bool w_bi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int32_t p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SetMaxThreads(Int32, Int32) declare in System.Threading.ThreadPool
bool w_bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean OpenAsset(Int32, Int32, Int32) declare in UnityEditor.AssetDatabase
bool w_bi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ForAll(Int32, Int32, System.Predicate`1[System.Int32]) declare in System.Diagnostics.Contracts.Contract
bool w_bi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(int32_t p0, int32_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasHandler(Int32, System.Delegate) declare in UnityEditor.DragAndDrop
bool w_bi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(int32_t p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsJsValueTypeMatchType(Puerts.JsValueType, System.Type, Puerts.JsValueType, GetValueForCheck, System.Object) declare in Puerts.Utils
bool w_bi4oi4DoDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4oi4DoDO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef bool (*FuncToCall)(int32_t p0, Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HandleRetry(RetryType, System.Exception, System.String, PlasticPipe.PlasticServer, PlasticPipe.Client.DnsResolveNameToIp, UInt32) declare in PlasticPipe.Client.InvokeMethodRetry
bool w_bi4osoou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4osoou4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(int32_t p0, Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, uint32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsMatch(Int32, IntPtr, Puerts.JsValueType, System.Type, Boolean, Boolean, IntPtr, System.Object ByRef, Puerts.JsValueType ByRef) declare in Puerts.ArgHelper
bool w_bi4pi4obbpPOPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4pi4obbpPOPi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5)) return false;
        if (!apis->is_binary(env, _sv6) && !apis->is_null(env, _sv6) && !apis->is_undefined(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
        if (!apis->is_boxed_value(env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    void* p6 = DataTransfer::GetPointer<void>(apis, env, _sv6);
    // JSValToCSVal Po/PO
    Il2CppObject* up7 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv7)); // object ref
    Il2CppObject** p7 = &up7;
        
    // JSValToCSVal P primitive
    int32_t up8 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv8);
    int32_t* p8 = &up8;

    typedef bool (*FuncToCall)(int32_t p0, void* p1, int32_t p2, Il2CppObject* p3, bool p4, bool p5, void* p6, Il2CppObject** p7, int32_t* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    apis->update_boxed_value(env, _sv7, CSRefToJsValue(apis, env, TIp7, *p7));
    apis->update_boxed_value(env, _sv8, converter::Converter<int32_t>::toScript(apis, env, *p8));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetBoolean(Int32, IntPtr, Puerts.IGetValueFromJs, IntPtr, Boolean) declare in Puerts.PrimitiveTypeTranslate
bool w_bi4popb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4popb");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(int32_t p0, void* p1, Il2CppObject* p2, void* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsMatchParams(Int32, IntPtr, IntPtr, Puerts.JsValueType, System.Type, Int32, Int32, IntPtr, System.Object ByRef, Puerts.JsValueType ByRef) declare in Puerts.ArgHelper
bool w_bi4ppi4oi4i4pPOPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4ppi4oi4i4pPOPi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);

    if (checkJSArgument) {
        if (js_args_len != 10) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!apis->is_binary(env, _sv7) && !apis->is_null(env, _sv7) && !apis->is_undefined(env, _sv7)) return false;
        if (!apis->is_boxed_value(env, _sv8)) return false;
        if (!apis->is_boxed_value(env, _sv9)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    void* p7 = DataTransfer::GetPointer<void>(apis, env, _sv7);
    // JSValToCSVal Po/PO
    Il2CppObject* up8 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv8)); // object ref
    Il2CppObject** p8 = &up8;
        
    // JSValToCSVal P primitive
    int32_t up9 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv9);
    int32_t* p9 = &up9;

    typedef bool (*FuncToCall)(int32_t p0, void* p1, void* p2, int32_t p3, Il2CppObject* p4, int32_t p5, int32_t p6, void* p7, Il2CppObject** p8, int32_t* p9, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    apis->update_boxed_value(env, _sv8, CSRefToJsValue(apis, env, TIp8, *p8));
    apis->update_boxed_value(env, _sv9, converter::Converter<int32_t>::toScript(apis, env, *p9));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetDialogOptOutDecision(UnityEditor.DialogOptOutDecisionType, System.String) declare in UnityEditor.EditorUtility
bool w_bi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi4s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int32_t p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Int64) declare in System.Convert
bool w_bi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(int64_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(Int64, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_bi8S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(int64_t p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_LessThan(Int64, System.Numerics.BigInteger) declare in System.Numerics.BigInteger
bool w_bi8S_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(apis, env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};

    typedef bool (*FuncToCall)(int64_t p0, struct S_i4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryStartNoGCRegion(Int64, Boolean) declare in System.GC
bool w_bi8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int64_t p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryStartNoGCRegion(Int64, Int64) declare in System.GC
bool w_bi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(int64_t p0, int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryStartNoGCRegion(Int64, Int64, Boolean) declare in System.GC
bool w_bi8i8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8i8b");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(int64_t p0, int64_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Any(Int64, System.Collections.Generic.List`1[PlasticGui.WorkspaceWindow.CodeReview.ReviewChanges.Comments.CodeReviewCommentIndented]) declare in PlasticGui.WorkspaceWindow.CodeReview.ReviewChanges.Comments.HasCommentReply
bool w_bi8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bi8o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(int64_t p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsFirstRun(System.ActivationContext) declare in System.Deployment.Internal.InternalActivationContextHelper
bool w_bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef bool (*FuncToCall)(Il2CppObject* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean InstallIdentifier(NugetForUnity.Models.INugetPackageIdentifier, Boolean, Boolean, Boolean) declare in NugetForUnity.NugetPackageInstaller
bool w_boDbDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boDbDbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsNonGenericOrValidGeneric(System.Reflection.MethodInfo, System.Reflection.ParameterInfo[]) declare in PuertsIl2cpp.TypeUtils
bool w_boDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref  with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 1, TIp1);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean MakeEditable(System.String[], System.String, System.Collections.Generic.List`1[System.String]) declare in UnityEditor.AssetDatabase
bool w_boDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boDsDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDefined(System.Type, System.Object) declare in System.Enum
bool w_boO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsValid(System.Type, System.Object, System.ComponentModel.License ByRef) declare in System.ComponentModel.LicenseManager
bool w_boOPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boOPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ExpandoTryDeleteValue(System.Dynamic.ExpandoObject, System.Object, Int32, System.String, Boolean) declare in System.Runtime.CompilerServices.RuntimeOps
bool w_boOi4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boOi4sb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ExpandoTryGetValue(System.Dynamic.ExpandoObject, System.Object, Int32, System.String, Boolean, System.Object ByRef) declare in System.Runtime.CompilerServices.RuntimeOps
bool w_boOi4sbPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boOi4sbPO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv5)); // object ref
    Il2CppObject** p5 = &up5;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, bool p4, Il2CppObject** p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv5, CSRefToJsValue(apis, env, TIp5, *p5));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SetManagedReferenceIdForObject(UnityEngine.Object, System.Object, Int64) declare in UnityEngine.Serialization.ManagedReferenceUtility
bool w_boOi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boOi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCreatePlaneFromPolygon(UnityEngine.Vector3[], UnityEngine.Plane ByRef) declare in UnityEngine.GeometryUtility
bool w_boPS_S_r4r4r4_r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_S_r4r4r4_r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_r4r4r4_r4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_r4r4r4_r4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_S_r4r4r4_r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetObjectIdentifier(UnityEngine.Object, UnityEditor.Build.Content.ObjectIdentifier ByRef) declare in UnityEditor.Build.Content.ObjectIdentifier
bool w_boPS_S_u4u4u4u4_i8i4s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_S_u4u4u4u4_i8i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_u4u4u4u4_i8i4s_* p1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u4u4u4u4_i8i4s_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u4u4u4u4_i8i4s_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_S_u4u4u4u4_i8i4s_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PassHasKeyword(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEngine.Rendering.LocalKeyword ByRef) declare in UnityEditor.ShaderUtil
bool w_boPS_u4u4_PS_S_p_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_u4u4_PS_S_p_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4_* p1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_p_su4_* p2 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_p_su4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_p_su4_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_* p1, struct S_S_p_su4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PassHasKeyword(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEngine.Rendering.LocalKeyword ByRef, UnityEditor.Rendering.ShaderType) declare in UnityEditor.ShaderUtil
bool w_boPS_u4u4_PS_S_p_su4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_u4u4_PS_S_p_su4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4_* p1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_p_su4_* p2 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_p_su4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_p_su4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_* p1, struct S_S_p_su4_* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PassHasKeyword(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEngine.Rendering.LocalKeyword ByRef, UnityEditor.Rendering.ShaderType, UnityEditor.Rendering.ShaderCompilerPlatform) declare in UnityEditor.ShaderUtil
bool w_boPS_u4u4_PS_S_p_su4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_u4u4_PS_S_p_su4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4_* p1 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4_));
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    S_S_p_su4_* p2 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_p_su4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_p_su4_));
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_u4u4_* p1, struct S_S_p_su4_* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
            
    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGizmoInfo(System.Type, UnityEditor.GizmoInfo ByRef) declare in UnityEditor.GizmoUtility
bool w_boPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryConvertToDouble(UnityEditor.Search.SearchItem, Double ByRef, System.String) declare in UnityEditor.Search.SearchExpression
bool w_boPr8Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPr8Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P primitive
    double up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;
    // JSValToCSVal string  with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, double* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<double>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ValidateTextureStack(UnityEngine.Texture[], System.String ByRef) declare in UnityEngine.Rendering.VirtualTexturing.EditorHelpers
bool w_boPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGUIDAndLocalFileIdentifier(UnityEngine.Object, System.String ByRef, Int32 ByRef) declare in UnityEditor.AssetDatabase
bool w_boPsPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPsPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString** p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGUIDAndLocalFileIdentifier(UnityEngine.Object, System.String ByRef, Int64 ByRef) declare in UnityEditor.AssetDatabase
bool w_boPsPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPsPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString** p1, int64_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetXmlElementForInteropType(System.Type, System.String ByRef, System.String ByRef) declare in System.Runtime.Remoting.SoapServices
bool w_boPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString** p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CanOpenForEdit(UnityEngine.Object, System.String ByRef, UnityEditor.StatusQueryOptions) declare in UnityEditor.AssetDatabase
bool w_boPsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boPsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString** p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.String[], Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_boS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_O_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_O_* pp1 = DataTransfer::GetPointer<S_O_>(apis, env, _sv1);
    S_O_ p1 = pp1 ? *pp1 : S_O_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_O_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ReadDirectoryChangesW(Microsoft.Win32.SafeHandles.SafeFileHandle, System.Runtime.InteropServices.HandleRef, Int32, Int32, Int32, Int32 ByRef, IntPtr, System.Runtime.InteropServices.HandleRef) declare in Codice.Client.Common.FsNodeReaders.Watcher.MonoFileSystemWatcher
bool w_boS_Op_i4i4i4Pi4pS_Op_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_Op_i4i4i4Pi4pS_Op_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_binary(env, _sv6) && !apis->is_null(env, _sv6) && !apis->is_undefined(env, _sv6)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_Op_* pp1 = DataTransfer::GetPointer<S_Op_>(apis, env, _sv1);
    S_Op_ p1 = pp1 ? *pp1 : S_Op_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P any
    void* p6 = DataTransfer::GetPointer<void>(apis, env, _sv6);
    // JSValToCSVal struct
    S_Op_* pp7 = DataTransfer::GetPointer<S_Op_>(apis, env, _sv7);
    S_Op_ p7 = pp7 ? *pp7 : S_Op_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_Op_ p1, int32_t p2, int32_t p3, int32_t p4, int32_t* p5, void* p6, struct S_Op_ p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Check(UnityEditor.Search.SearchExpression, UnityEditor.Search.SearchExpressionContext) declare in UnityEditor.Search.SearchExpression
bool w_boS_S_oooo_ooi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_S_oooo_ooi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_S_oooo_ooi4_* pp1 = DataTransfer::GetPointer<S_S_oooo_ooi4_>(apis, env, _sv1);
    S_S_oooo_ooi4_ p1 = pp1 ? *pp1 : S_S_oooo_ooi4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_S_oooo_ooi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TestPlanesAABB(UnityEngine.Plane[], UnityEngine.Bounds) declare in UnityEngine.GeometryUtility
bool w_boS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsTouching(UnityEngine.Collider2D, UnityEngine.ContactFilter2D) declare in UnityEngine.Physics2D
bool w_boS_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_bbbbbbS_i4_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CanMoveTransformToScene(UnityEngine.Transform, UnityEngine.SceneManagement.Scene) declare in UnityEditor.SceneManagement.SceneHierarchyHooks
bool w_boS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean UpdateNavMeshData(UnityEngine.AI.NavMeshData, UnityEngine.AI.NavMeshBuildSettings, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource], UnityEngine.Bounds) declare in UnityEngine.AI.NavMeshBuilder
bool w_boS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__* pp1 = DataTransfer::GetPointer<S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__>(apis, env, _sv1);
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p1 = pp1 ? *pp1 : S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv3);
    S_S_r4r4r4_S_r4r4r4__ p3 = pp3 ? *pp3 : S_S_r4r4r4_S_r4r4r4__ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p1, Il2CppObject* p2, struct S_S_r4r4r4_S_r4r4r4__ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SpinUntil(System.Func`1[System.Boolean], System.TimeSpan) declare in System.Threading.SpinWait
bool w_boS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WaitAll(System.Threading.WaitHandle[], System.TimeSpan, Boolean) declare in System.Threading.WaitHandle
bool w_boS_i8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i8_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_i8_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ScreenPointToLocalPointInRectangle(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector2 ByRef) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_oPS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oPS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_r4r4_* p3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, Il2CppObject* p2, struct S_r4r4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ScreenPointToWorldPointInRectangle(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector3 ByRef) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_oPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oPS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_r4r4r4_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector4) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_oS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ComputePenetration(UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3 ByRef, Single ByRef) declare in UnityEngine.Physics
bool w_boS_r4r4r4_S_r4r4r4r4_oS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4r4_S_r4r4r4r4_oS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (checkJSArgument) {
        if (js_args_len != 8) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
        if (!apis->is_boxed_value(env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
    // JSValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    S_r4r4r4_* p6 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv6)); // valuetype ref
    S_r4r4r4_ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(S_r4r4r4_));
        p6 = &up6;
    }
        
    // JSValToCSVal P primitive
    float up7 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv7);
    float* p7 = &up7;

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, struct S_r4r4r4_* p6, float* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (p6 == &up6)
    {
        apis->update_boxed_value(env, _sv6, DataTransfer::CopyValueType(apis, env, *p6, TIp6));
    }
            
    apis->update_boxed_value(env, _sv7, converter::Converter<float>::toScript(apis, env, *p7));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsIntersectingRectTransform(UnityEngine.RectTransform, UnityEngine.Vector3, UnityEngine.Camera) declare in TMPro.TMP_TextUtilities
bool w_boS_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GenerateSecondaryUVSet(UnityEngine.Mesh, UnityEditor.UnwrapParam) declare in UnityEditor.Unwrapping
bool w_boS_r4r4r4r4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4i4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4_>(apis, env, _sv1);
    S_r4r4r4r4i4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_r4r4r4r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetDiscreteIntValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding, Int32 ByRef) declare in UnityEditor.AnimationUtility
bool w_boS_sosi4i4i4i4i4i4i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_sosi4i4i4i4i4i4i4_ p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetObjectReferenceValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding, UnityEngine.Object ByRef) declare in UnityEditor.AnimationUtility
bool w_boS_sosi4i4i4i4i4i4i4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_sosi4i4i4i4i4i4i4_ p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetFloatValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding, Single ByRef) declare in UnityEditor.AnimationUtility
bool w_boS_sosi4i4i4i4i4i4i4_Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppObject* p0, struct S_sosi4i4i4i4i4i4i4_ p1, float* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Texture, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_boVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppArray* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BeginToggleGroup(UnityEngine.GUIContent, Boolean) declare in UnityEditor.EditorGUILayout
bool w_bob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawSubHeaderFoldout(UnityEngine.GUIContent, Boolean, Boolean) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bobDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bobDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawSubHeaderFoldout(UnityEngine.GUIContent, Boolean, Boolean, System.Func`1[System.Boolean], System.Action) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bobDbDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bobDbDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderFoldout(UnityEngine.GUIContent, Boolean, Boolean, System.Func`1[System.Boolean], System.Action, System.String, System.Action`1[UnityEngine.Vector2]) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bobDbDoDoDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bobDbDoDoDsDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal string  with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p6 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 6, TIp6);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppString* p5, Il2CppObject* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.GUIContent, Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_bobVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bobVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasPendingChanges(Codice.CM.Common.WorkspaceInfo, Boolean, Boolean, Boolean, Boolean) declare in Codice.Client.BaseCommands.VisiblePendingChangesChecker
bool w_bobbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bobbbb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, bool p2, bool p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_boboVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boboVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasConflicts(Codice.CM.Common.Merge.Difference, Boolean, Codice.CM.Common.Checkin.Partial.IHeadNodeFinder, System.StringComparison) declare in Codice.CM.Common.Checkin.Partial.ConflictCheckers.DeletedConflictChecker
bool w_boboi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boboi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderToggleFoldout(UnityEngine.GUIContent, Boolean, UnityEditor.SerializedProperty, System.Action`1[UnityEngine.Vector2], System.Func`1[System.Boolean], System.Action, System.String) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_boboooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boboooos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(Il2CppObject* p0, bool p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppString* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Merge(Codice.CM.Common.WorkspaceInfo, Codice.Client.Commands.MergeContributorType, Codice.CM.Common.Partial.GluonFileConflict, System.String, Codice.Client.BaseCommands.FileTypeChecker, Codice.Client.Commands.IToolLauncher) declare in Codice.Client.GameUI.Checkin.MergeGluonFileConflict
bool w_boi2osoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi2osoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int16_t p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Byte[], Int32) declare in System.BitConverter
bool w_boi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WaitAll(System.Threading.Tasks.Task[], Int32, System.Threading.CancellationToken) declare in System.Threading.Tasks.Task
bool w_boi4S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4S_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(apis, env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, struct S_o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DropdownButton(UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_boi4Vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WaitAll(System.Threading.WaitHandle[], Int32, Boolean) declare in System.Threading.WaitHandle
bool w_boi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean OpenAsset(UnityEngine.Object, Int32, Int32) declare in UnityEditor.AssetDatabase
bool w_boi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsRegionVisible(Codice.CM.Client.Differences.Graphic.TextRegion, Int32, Int32, Int32) declare in Codice.CM.Client.Differences.Graphic.TextRegionChecker
bool w_boi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ShadowRTNeedsReAlloc(UnityEngine.Rendering.RTHandle, Int32, Int32, Int32, Int32, Single, System.String) declare in UnityEngine.Rendering.Universal.ShadowUtils
bool w_boi4i4i4i4r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4i4i4r4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, float p5, Il2CppString* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GenerateAtlas(UnityEngine.Vector2[], Int32, Int32, System.Collections.Generic.List`1[UnityEngine.Rect]) declare in UnityEngine.Texture2D
bool w_boi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCompressWithZlib(Byte[], Int32, Byte[], Int32 ByRef) declare in Codice.CM.Common.Compression
bool w_boi4oPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4oPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DropdownButton(UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_boi4oVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4oVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ConvertTexture(UnityEngine.Texture, Int32, UnityEngine.Texture, Int32) declare in UnityEngine.Graphics
bool w_boi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Check(Codice.Client.BaseCommands.Differences.IPreviewGeneratorFactory, Codice.CM.Common.EnumRevisionType, System.String) declare in Codice.Client.BaseCommands.Differences.IsDiffUnsuportedBinType
bool w_boi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int32_t p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ClearManagedReferenceWithMissingType(UnityEngine.Object, Int64) declare in UnityEditor.SerializationUtility
bool w_boi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetCachedBranchName(Codice.CM.Common.RepositorySpec, Int64, System.String ByRef) declare in PlasticGui.WorkspaceWindow.BranchInfoCache
bool w_boi8Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi8Ps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Update(Codice.CM.Common.RepositoryInfo, Int64, System.String) declare in Codice.Client.BaseCommands.CheckIn.CodeReview.UpdateChangeRequestsAppliedInChangeset
bool w_boi8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi8s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckBranchExists(Codice.CM.Common.RepositorySpec, Int64, System.String, System.String ByRef) declare in PlasticGui.InputValidator
bool w_boi8sPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boi8sPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, int64_t p1, Il2CppString* p2, Il2CppString** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.Type, System.Type) declare in System.Type
bool w_boo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Update(NugetForUnity.Models.INugetPackageIdentifier, NugetForUnity.Models.INugetPackage, Boolean, NugetForUnity.PluginAPI.PackageUninstallReason) declare in NugetForUnity.NugetPackageUpdater
bool w_booDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booDbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCreate(System.Uri, System.Uri, System.Uri ByRef) declare in System.Uri
bool w_booPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsEditableEntry(Codice.CM.Common.WorkspaceInfo, Codice.CM.Common.DiffViewEntry, System.String ByRef) declare in Codice.Client.BaseCommands.Differences.EditableDiffViewEntryCalculator
bool w_booPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsTouching(UnityEngine.Collider2D, UnityEngine.Collider2D, UnityEngine.ContactFilter2D) declare in UnityEngine.Physics2D
bool w_booS_bbbbbbS_i4_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booS_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(apis, env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle, System.TimeSpan, Boolean) declare in System.Threading.WaitHandle
bool w_booS_i8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booS_i8_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_i8_ p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreAllIgnoredRulesDefined(Codice.CM.Common.WorkspaceInfo, PlasticGui.Help.GuiHelpEvents, System.DateTime) declare in PlasticGui.Help.Conditions.UnityConditions
bool w_booS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, struct S_u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(UnityEngine.Texture, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_booVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDefined(System.Reflection.MemberInfo, System.Type, Boolean) declare in System.Attribute
bool w_boob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PropertyField(UnityEditor.SerializedProperty, UnityEngine.GUIContent, Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_boobVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boobVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, bool p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDerivedFrom(System.Xml.Schema.XmlSchemaType, System.Xml.Schema.XmlSchemaType, System.Xml.Schema.XmlSchemaDerivationMethod) declare in System.Xml.Schema.XmlSchemaType
bool w_booi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ShowSaveDialog(OnSuccess, OnCancel, PickMode, Boolean, System.String, System.String, System.String, System.String) declare in SimpleFileBrowser.FileBrowser
bool w_booi4DbDsDsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booi4DbDsDsDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (js_args_len > 4 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (js_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (js_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
        if (js_args_len > 7 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 3);
                
    // JSValToCSVal string  with default
    Il2CppString* p4 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 4);
                
    // JSValToCSVal string  with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 5);
                
    // JSValToCSVal string  with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 6);
                
    // JSValToCSVal string  with default
    Il2CppString* p7 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 7);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, bool p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, Il2CppString* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Upgrade(UnityEngine.Material, System.Collections.Generic.List`1[UnityEditor.Rendering.MaterialUpgrader], UpgradeFlags, System.String ByRef) declare in UnityEditor.Rendering.MaterialUpgrader
bool w_booi4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booi4Ps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, Il2CppString** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle, Int32, Boolean) declare in System.Threading.WaitHandle
bool w_booi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsDifferenceRegionVisible(Codice.CM.Client.Differences.Graphic.TextRegion, Codice.CM.Client.Differences.Graphic.TextRegion, Int32, Int32, Int32, Int32) declare in Codice.CM.Client.Differences.Graphic.TextRegionChecker
bool w_booi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsInProgress(Codice.CM.Common.WorkspaceInfo, PlasticGui.IPlasticAPI, Int64, Int64, Codice.CM.Common.MergeType) declare in PlasticGui.WorkspaceWindow.Merge.MergeInProgress
bool w_booi8i8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booi8i8u1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    uint8_t p4 = converter::Converter<uint8_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, int64_t p2, int64_t p3, uint8_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RegisterDynamicProperty(System.Runtime.Remoting.Contexts.IDynamicProperty, System.ContextBoundObject, System.Runtime.Remoting.Contexts.Context) declare in System.Runtime.Remoting.Contexts.Context
bool w_booo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderToggle(UnityEngine.GUIContent, UnityEditor.SerializedProperty, UnityEditor.SerializedProperty, System.Action`1[UnityEngine.Vector2], System.Func`1[System.Boolean], System.Action) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_boooDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooDoDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ApplyForGluon(Codice.CM.Common.WorkspaceInfo, System.Collections.Generic.List`1[Codice.Client.BaseCommands.ChangeInfo], Codice.Client.Commands.MovedMatchingOptions, System.Collections.Generic.List`1[Codice.CM.Common.ItemError] ByRef) declare in Codice.Client.BaseCommands.Merge.ApplyWorkspaceLocalChanges
bool w_boooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetSensorGateFrustum(UnityEngine.Camera, UnityEngine.Vector3[], UnityEngine.Vector3[], Single ByRef) declare in UnityEditor.CameraEditorUtils
bool w_boooPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, float* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<float>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean LabelChangeset(Codice.Client.Commands.ICmdNotifier, Codice.CM.Common.RepositorySpec, Codice.CM.Common.WorkspaceInfo, Int64, Int64) declare in Codice.Client.BaseCommands.Labeler
bool w_boooi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooi8i8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, int64_t p3, int64_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Verify_v15(System.Security.Cryptography.RSA, System.Security.Cryptography.HashAlgorithm, Byte[], Byte[]) declare in Mono.Security.Cryptography.PKCS1
bool w_boooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGet(Codice.CM.Common.RepositoryInfo, Codice.CM.Common.BranchInfo, Codice.CM.Interfaces.IItemHandler, Codice.CM.Interfaces.IBranchHandler, Int64 ByRef) declare in Codice.Client.BaseCommands.GetParentBranchCommonAncestor
bool w_booooPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booooPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv4);
    int64_t* p4 = &up4;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, int64_t* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<int64_t>::toScript(apis, env, *p4));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Apply(Codice.CM.Common.WorkspaceInfo, System.Collections.Generic.List`1[System.String], Codice.Client.BaseCommands.ApplyLocalChangesOptions, Codice.Client.Commands.ICmdNotifier, System.Collections.Generic.List`1[System.String] ByRef, System.Collections.Generic.List`1[Codice.CM.Common.ItemError] ByRef) declare in Codice.Client.BaseCommands.ApplyChanges
bool w_booooPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booooPoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ref
    Il2CppObject** p4 = &up4;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv5)); // object ref
    Il2CppObject** p5 = &up5;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject** p4, Il2CppObject** p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv4, CSRefToJsValue(apis, env, TIp4, *p4));
    apis->update_boxed_value(env, _sv5, CSRefToJsValue(apis, env, TIp5, *p5));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Verify_v15(System.Security.Cryptography.RSA, System.Security.Cryptography.HashAlgorithm, Byte[], Byte[], Boolean) declare in Mono.Security.Cryptography.PKCS1
bool w_boooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean UsingTokenInTokenCache(PlasticPipe.PlasticServer, Codice.CM.Common.Credentials, ClientConfLoginInfo, IGetCredentials, IAuthTokenCache, Codice.Client.Common.ProfileManager, Codice.CM.Common.Credentials ByRef) declare in Codice.Client.Common.Connection.TryRenewToken
bool w_booooooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booooooPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal Po/PO
    Il2CppObject* up6 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv6)); // object ref
    Il2CppObject** p6 = &up6;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject** p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv6, CSRefToJsValue(apis, env, TIp6, *p6));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TrySolveMergeToFileConflicts(Codice.CM.Common.MergeSource, Codice.CM.Common.MergeResult, Codice.Client.BaseCommands.Merge.MergeResolutionOptions, Codice.Client.BaseCommands.Merge.MergeSolvedFileConflicts, Codice.Client.Commands.IToolLauncher, Codice.Client.BaseCommands.Merge.MergeTo.MergeToFileTypeChecker, Codice.Client.Commands.IProgressNotifier) declare in Codice.Client.BaseCommands.Merge.MergeTo.MergeToFileConflictResolver
bool w_booooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_booooooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderToggle(UnityEngine.GUIContent, UnityEditor.SerializedProperty, UnityEditor.SerializedProperty, System.Action`1[UnityEngine.Vector2], System.Func`1[System.Boolean], System.Action, System.String) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_boooooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boooooos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppString* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BlendCubemap(UnityEngine.Texture, UnityEngine.Texture, Single, UnityEngine.RenderTexture) declare in UnityEngine.ReflectionProbe
bool w_boor4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boor4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, float p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BuildAssetBundle(UnityEngine.Object, UnityEngine.Object[], System.String, UInt32 ByRef, UnityEditor.BuildAssetBundleOptions, UnityEditor.BuildTarget) declare in UnityEditor.BuildPipeline
bool w_boosPu4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boosPu4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, uint32_t* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BuildAssetBundle(UnityEngine.Object, UnityEngine.Object[], System.String, UnityEditor.BuildAssetBundleOptions, UnityEditor.BuildTarget) declare in UnityEditor.BuildPipeline
bool w_boosi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boosi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsFsNodeChangedAndItsContentCheckedOnWorkspace(Codice.CM.Common.WorkspaceInfo, Codice.Client.Commands.FileLocalInfo, System.String, Codice.Client.Common.FsNode, Boolean, Boolean ByRef) declare in Codice.Client.BaseCommands.ChangedFileChecker
bool w_boosobPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boosobPb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    // JSValToCSVal P primitive
    bool up5 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv5);
    bool* p5 = &up5;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, bool p4, bool* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv5, converter::Converter<bool>::toScript(apis, env, *p5));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CanBeAnnotated(Codice.Client.BaseCommands.Config.IGlobalConfig, Codice.CM.Common.WorkspaceInfo, System.String, System.String, System.String, Codice.CM.Common.RevisionInfo) declare in PlasticGui.AnnotateItemCheck
bool w_boossso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_boossso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(Mono.Unix.Native.Sockaddr, IntPtr) declare in Mono.Unix.Native.NativeConvert
bool w_bop(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BuildAssetStoreAssetBundle(UnityEngine.Object, System.String) declare in UnityEditorInternal.AssetStoreToolUtils
bool w_bos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean MatchSearchGroups(UnityEditor.Search.SearchContext, System.String, Boolean) declare in UnityEditor.Search.SearchUtils
bool w_bosDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.Type, System.String, System.Object ByRef) declare in System.Enum
bool w_bosPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosPO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCreate(System.Uri, System.String, System.Uri ByRef) declare in System.Uri
bool w_bosPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetStat(UnityEngine.IntegratedSubsystem, System.String, Single ByRef) declare in UnityEngine.XR.Provider.XRStats
bool w_bosPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, float* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<float>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckLabelExists(Codice.CM.Common.RepositorySpec, System.String, System.String ByRef) declare in PlasticGui.InputValidator
bool w_bosPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetTargetAndSolveFinalPath(Codice.Client.Common.ISolveSymlinks, System.String, System.String ByRef, System.String ByRef) declare in Codice.Client.Common.SolveSymlinks
bool w_bosPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString** p2, Il2CppString** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BumpMapTextureNeedsFixingInternal(UnityEngine.Material, System.String, Boolean) declare in UnityEditorInternal.InternalEditorUtility
bool w_bosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.Type, System.String, Boolean, System.Object ByRef) declare in System.Enum
bool w_bosbPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosbPO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ref
    Il2CppObject** p3 = &up3;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, bool p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, CSRefToJsValue(apis, env, TIp3, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsChangedFsNode(Codice.Client.Commands.FileLocalInfo, System.String, Codice.Client.Common.FsNode, Boolean) declare in Codice.Client.BaseCommands.ChangedFileChecker
bool w_bosob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsFsNodeChangedAndItsContentChecked(Codice.Client.Commands.FileLocalInfo, System.String, Codice.Client.Common.FsNode, Boolean, Boolean ByRef) declare in Codice.Client.BaseCommands.ChangedFileChecker
bool w_bosobPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosobPb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P primitive
    bool up4 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv4);
    bool* p4 = &up4;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, bool p3, bool* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<bool>::toScript(apis, env, *p4));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsPersistantListenerValid(UnityEngine.Events.UnityEventBase, System.String, UnityEngine.Object, UnityEngine.Events.PersistentListenerMode, System.Type) declare in UnityEditorInternal.UnityEventDrawer
bool w_bosoi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosoi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Check(Codice.CM.Common.CodeReviewData, System.String, Codice.CM.Client.Differences.IBigFileChecker, Codice.Client.BaseCommands.Differences.IPreviewGeneratorFactory) declare in Codice.Client.BaseCommands.Differences.IsDiffBigFile
bool w_bosoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetXlinkRepository(ITreeSolver, System.String, Codice.CM.Common.RepositorySpec, Codice.CM.WorkspaceServer.SelectorSolverContent, Codice.CM.Common.RepositoryInfo ByRef) declare in Codice.CM.WorkspaceServer.XlinkTreeResolver
bool w_bosooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosooPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ref
    Il2CppObject** p4 = &up4;
        

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject** p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, CSRefToJsValue(apis, env, TIp4, *p4));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetFloatValue(UnityEngine.GameObject, System.String, System.Type, System.String, Single ByRef) declare in UnityEditor.AnimationUtility
bool w_bososPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bososPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P primitive
    float up4 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv4);
    float* p4 = &up4;

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, Il2CppString* p3, float* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    apis->update_boxed_value(env, _sv4, converter::Converter<float>::toScript(apis, env, *p4));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WarnPrefab(UnityEngine.Object, System.String, System.String, System.String) declare in UnityEditor.EditorUtility
bool w_bosss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bosss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppObject* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreAllLocksHeld(Codice.CM.Common.WorkspaceInfo, Codice.CM.WorkspaceServer.WorkspaceLockTypes) declare in Codice.CM.WorkspaceServer.WorkspaceLock
bool w_bou1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bou1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, uint8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Mono.Math.BigInteger, UInt32) declare in Mono.Math.BigInteger
bool w_bou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bou4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppObject* p0, uint32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean BindHandle(IntPtr) declare in System.Threading.ThreadPool
bool w_bp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Flock ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_i2i2i8i8i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_i2i2i8i8i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i2i2i8i8i4_* p1 = DataTransfer::GetPointer<S_i2i2i8i8i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i2i2i8i8i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i2i2i8i8i4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_i2i2i8i8i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Pollfd ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_i4i2i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_i4i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i2i2_* p1 = DataTransfer::GetPointer<S_i4i2i2_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i2i2_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_i4i2i2_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Linger ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i4_* p1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_i4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Cmsghdr ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_i8i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_i8i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i8i4i4_* p1 = DataTransfer::GetPointer<S_i8i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8i4i4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_i8i4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Timespec ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i8i8_* p1 = DataTransfer::GetPointer<S_i8i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8i8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_i8i8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Iovec ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_pu8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_pu8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_pu8_* p1 = DataTransfer::GetPointer<S_pu8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_pu8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_pu8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_pu8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.InAddr ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4_* p1 = DataTransfer::GetPointer<S_u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_u4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.In6Addr ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8u8_* p1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_u8u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Stat ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* p1 = DataTransfer::GetPointer<S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_u8u8u4u4u8u4u4u8i8i8i8i8i8i8i8i8i8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.Statvfs ByRef) declare in Mono.Unix.Native.NativeConvert
bool w_bpPS_u8u8u8u8u8u8u8u8u8u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpPS_u8u8u8u8u8u8u8u8u8u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8u8u8u8u8u8u8u8u8u8u8_* p1 = DataTransfer::GetPointer<S_u8u8u8u8u8u8u8u8u8u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8u8u8u8u8u8u8u8u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8u8u8u8u8u8u8u8u8u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct S_u8u8u8u8u8u8u8u8u8u8u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetBooleanArrayElement(IntPtr, Int32) declare in UnityEngine.AndroidJNI
bool w_bpi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RegisterFunction(IntPtr, Int32, System.String, Boolean, Puerts.V8FunctionCallback, Int64) declare in Puerts.PuertsDLL
bool w_bpi4sboi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4sboi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, Il2CppString* p2, bool p3, Il2CppObject* p4, int64_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RegisterProperty(IntPtr, Int32, System.String, Boolean, Puerts.V8FunctionCallback, Int64, Puerts.V8FunctionCallback, Int64, Boolean) declare in Puerts.PuertsDLL
bool w_bpi4sboi8oi8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4sboi8oi8b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv5)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal o/O
    Il2CppObject* p6 = JsValueToCSRef(apis, TIp6, env, _sv6);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, Il2CppString* p2, bool p3, Il2CppObject* p4, int64_t p5, Il2CppObject* p6, int64_t p7, bool p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RegisterFunction(IntPtr, Int32, System.String, Boolean, IntPtr, Int64) declare in Puerts.PuertsDLL
bool w_bpi4sbpi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4sbpi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!apis->is_binary(env, _sv4) && !apis->is_null(env, _sv4) && !apis->is_undefined(env, _sv4)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    void* p4 = DataTransfer::GetPointer<void>(apis, env, _sv4);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, Il2CppString* p2, bool p3, void* p4, int64_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean RegisterProperty(IntPtr, Int32, System.String, Boolean, IntPtr, Int64, IntPtr, Int64, Boolean) declare in Puerts.PuertsDLL
bool w_bpi4sbpi8pi8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4sbpi8pi8b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!apis->is_binary(env, _sv4) && !apis->is_null(env, _sv4) && !apis->is_undefined(env, _sv4)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv5)) return false;
        if (!apis->is_binary(env, _sv6) && !apis->is_null(env, _sv6) && !apis->is_undefined(env, _sv6)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    void* p4 = DataTransfer::GetPointer<void>(apis, env, _sv4);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(apis, env, _sv5);
    // JSValToCSVal P any
    void* p6 = DataTransfer::GetPointer<void>(apis, env, _sv6);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, Il2CppString* p2, bool p3, void* p4, int64_t p5, void* p6, int64_t p7, bool p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Int64, Mono.Unix.Native.Sockaddr) declare in Mono.Unix.Native.NativeConvert
bool w_bpi8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpi8o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(void* p0, int64_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryCopy(IntPtr, Mono.Unix.Native.SockaddrIn) declare in Mono.Unix.Native.NativeConvert
bool w_bpo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(void* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(IntPtr, IntPtr) declare in System.IntPtr
bool w_bpp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CallBooleanMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*) declare in UnityEngine.AndroidJNI
bool w_bppPv(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bppPv");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CallBooleanMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue]) declare in UnityEngine.AndroidJNI
bool w_bppS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bppS_S_p_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};

    typedef bool (*FuncToCall)(void* p0, void* p1, struct S_S_p_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetBooleanFromValue(IntPtr, IntPtr, Boolean) declare in Puerts.PuertsDLL
bool w_bppb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CallBooleanMethod(IntPtr, IntPtr, UnityEngine.jvalue[]) declare in UnityEngine.AndroidJNI
bool w_bppo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(void* p0, void* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean pesapi_get_value_bool(IntPtr, IntPtr, IntPtr) declare in Puerts.NativeAPI
bool w_bppp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean pesapi_get_private(IntPtr, IntPtr, IntPtr, IntPtr ByRef) declare in Puerts.NativeAPI
bool w_bpppPp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpppPp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P not primitive
    void** p3 = nullptr;

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, void** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, apis->create_binary(env, *p3, 0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean pesapi_is_instance_of(IntPtr, IntPtr, IntPtr, IntPtr) declare in Puerts.NativeAPI
bool w_bpppp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!apis->is_binary(env, _sv3) && !apis->is_null(env, _sv3) && !apis->is_undefined(env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(apis, env, _sv3);

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IdleNotificationDeadline(IntPtr, Double) declare in Puerts.PuertsDLL
bool w_bpr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bpr8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(void* p0, double p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ClearModuleCache(IntPtr, System.String) declare in Puerts.PuertsDLL
bool w_bps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(void* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Single) declare in System.Convert
bool w_br4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(float p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(Single, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_br4S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br4S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(float p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Single, Single) declare in System.Single
bool w_br4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(float p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreAlmostEqualUlps(Single, Single, Int32) declare in NUnit.Framework.Constraints.FloatingPointNumerics
bool w_br4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4i4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(float p0, float p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreEqual(Single, Single, Single) declare in UnityEngine.Assertions.Comparers.FloatComparer
bool w_br4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(float p0, float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ShowCameraPreviewAt(Single, Single, Single, Single) declare in UnityEngine.Apple.ReplayKit.ReplayKit
bool w_br4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4r4r4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(Double) declare in System.Convert
bool w_br8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(double p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFormat(Double, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat) declare in System.Buffers.Text.Utf8Formatter
bool w_br8S_S_p_i4_Pi4DS_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br8S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
    // JSValToCSVal valuetype  with default
    S_u1u1_ p3 = OptionalParameter<S_u1u1_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(double p0, struct S_S_p_i4_ p1, int32_t* p2, struct S_u1u1_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(Double, Double) declare in System.Double
bool w_br8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br8r8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(double p0, double p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreAlmostEqualUlps(Double, Double, Int64) declare in NUnit.Framework.Constraints.FloatingPointNumerics
bool w_br8r8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_br8r8i8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(double p0, double p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsNullOrEmpty(System.String) declare in System.String
bool w_bs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);

    typedef bool (*FuncToCall)(Il2CppString* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasGlobalDefine(System.String, System.Nullable`1[UnityEditor.BuildTargetGroup]) declare in DG.DOTweenEditor.EditorUtils
bool w_bsDN_bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsDN_bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal valuetype  with default
    N_bi4_ p1 = OptionalParameter<N_bi4_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, struct N_bi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CancelRequest(System.String, System.String) declare in UnityEditor.MPE.EventService
bool w_bsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (true) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal string  with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 1);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsVirtualPath(System.String, System.Object) declare in Codice.CM.Common.Merge.MergeVirtualPath
bool w_bsO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean QueueConfig(System.String, System.Object, Int32, System.String) declare in UnityEngine.RemoteConfigSettings
bool w_bsODi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsODi4Ds");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (js_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal string  with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bsPS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p1 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u8_i2_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u8_i2_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_S_u8_i2_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, UnityEditor.GlobalObjectId ByRef) declare in UnityEditor.GlobalObjectId
bool w_bsPS_S_u8u8_S_u4u4u4u4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_S_u8u8_S_u4u4u4u4_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_S_u8u8_S_u4u4u4u4_i4_* p1 = DataTransfer::GetPointer<S_S_u8u8_S_u4u4u4u4_i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_u8u8_S_u4u4u4u4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_S_u8u8_S_u4u4u4u4_i4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_S_u8u8_S_u4u4u4u4_i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Guid ByRef) declare in System.Guid
bool w_bsPS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Decimal ByRef) declare in System.Decimal
bool w_bsPS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4i4i4i4u8_* p1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4i4i4i4u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_i4i4i4i4u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Numerics.BigInteger ByRef) declare in System.Numerics.BigInteger
bool w_bsPS_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i4o_* p1 = DataTransfer::GetPointer<S_i4o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i4o_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_i4o_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bsPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_i8_* p1 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_i8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_i8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseHtmlString(System.String, UnityEngine.Color ByRef) declare in UnityEngine.ColorUtility
bool w_bsPS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_r4r4r4r4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindDevice(System.String, UnityEditor.Hardware.DevDevice ByRef) declare in UnityEditor.Hardware.DevDeviceList
bool w_bsPS_ssssi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_ssssi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_ssssi4i4_* p1 = DataTransfer::GetPointer<S_ssssi4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_ssssi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_ssssi4i4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_ssssi4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, UnityEditor.GUID ByRef) declare in UnityEditor.GUID
bool w_bsPS_u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u4u4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u4u4u4u4_* p1 = DataTransfer::GetPointer<S_u4u4u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u4u4u4u4_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_u4u4u4u4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.DateTime ByRef) declare in System.DateTime
bool w_bsPS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8_* p1 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetHashForAssetBundle(System.String, UnityEngine.Hash128 ByRef) declare in UnityEditor.BuildPipeline
bool w_bsPS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Pstruct
    S_u8u8_* p1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(S_u8u8_));
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_u8u8_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (p1 == &up1)
    {
        apis->update_boxed_value(env, _sv1, DataTransfer::CopyValueType(apis, env, *p1, TIp1));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Boolean ByRef) declare in System.Boolean
bool w_bsPb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, bool* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetPropertyOptionalBool(System.String, Boolean ByRef, UnityEditor.BuildTargetGroup) declare in UnityEditor.PlayerSettings
bool w_bsPbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPbi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    bool up1 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv1);
    bool* p1 = &up1;
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, bool* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<bool>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Char ByRef) declare in System.Char
bool w_bsPc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    Il2CppChar up1 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv1);
    Il2CppChar* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppChar* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppChar>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, SByte ByRef) declare in System.SByte
bool w_bsPi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int8_t up1 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv1);
    int8_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, int8_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int8_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Int16 ByRef) declare in System.Int16
bool w_bsPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int16_t up1 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv1);
    int16_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, int16_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Int32 ByRef) declare in System.Int32
bool w_bsPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Parse(System.String, Codice.CM.Common.EnumTriggerType ByRef, Codice.CM.Common.EnumTriggerEventType ByRef) declare in Codice.Client.Common.TriggerTypeParser
bool w_bsPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t* p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetPropertyOptionalInt(System.String, Int32 ByRef, UnityEditor.BuildTargetGroup) declare in UnityEditor.PlayerSettings
bool w_bsPi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Int64 ByRef) declare in System.Int64
bool w_bsPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, int64_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<int64_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Version ByRef) declare in System.Version
bool w_bsPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Single ByRef) declare in System.Single
bool w_bsPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, float* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<float>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Double ByRef) declare in System.Double
bool w_bsPr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPr8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    double up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, double* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<double>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CanOpenForEdit(System.String, System.String ByRef) declare in UnityEditor.AssetDatabase
bool w_bsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DecodeXmlNamespaceForClrTypeNamespace(System.String, System.String ByRef, System.String ByRef) declare in System.Runtime.Remoting.SoapServices
bool w_bsPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString** p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.String ByRef, System.String ByRef, System.String ByRef, System.String ByRef, System.String ByRef) declare in Codice.Client.Common.Specs.RevSpecParser
bool w_bsPsPsPsPsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsPsPsPsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    // JSValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    // JSValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        
    // JSValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString** p1, Il2CppString** p2, Il2CppString** p3, Il2CppString** p4, Il2CppString** p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<Il2CppString*>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv4, converter::Converter<Il2CppString*>::toScript(apis, env, *p4));
    apis->update_boxed_value(env, _sv5, converter::Converter<Il2CppString*>::toScript(apis, env, *p5));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetLocalFileSystemName(System.String, System.String ByRef, UInt64 ByRef, UInt64 ByRef) declare in Unity.IO.LowLevel.Unsafe.VirtualFileSystem
bool w_bsPsPu8Pu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsPu8Pu8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P primitive
    uint64_t up2 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv2);
    uint64_t* p2 = &up2;
    // JSValToCSVal P primitive
    uint64_t up3 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv3);
    uint64_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString** p1, uint64_t* p2, uint64_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    apis->update_boxed_value(env, _sv2, converter::Converter<uint64_t>::toScript(apis, env, *p2));
    apis->update_boxed_value(env, _sv3, converter::Converter<uint64_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsOpenForEdit(System.String, System.String ByRef, UnityEditor.StatusQueryOptions) declare in UnityEditorInternal.VersionControl.AssetModificationHook
bool w_bsPsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString** p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<Il2CppString*>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, Byte ByRef) declare in System.Byte
bool w_bsPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    uint8_t up1 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv1);
    uint8_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, uint8_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint8_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, UInt16 ByRef) declare in System.UInt16
bool w_bsPu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    uint16_t up1 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv1);
    uint16_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, uint16_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint16_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, UInt32 ByRef) declare in System.UInt32
bool w_bsPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    uint32_t up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, uint32_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, UInt64 ByRef) declare in System.UInt64
bool w_bsPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P primitive
    uint64_t up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;

    typedef bool (*FuncToCall)(Il2CppString* p0, uint64_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    apis->update_boxed_value(env, _sv1, converter::Converter<uint64_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.String, Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_bsS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_O_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_O_* pp1 = DataTransfer::GetPointer<S_O_>(apis, env, _sv1);
    S_O_ p1 = pp1 ? *pp1 : S_O_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_O_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryFromBase64String(System.String, System.Span`1[System.Byte], Int32 ByRef) declare in System.Convert
bool w_bsS_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_S_p_i4_Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_S_p_i4_ p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int32_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetArePrivateItemsHidden(System.String, System.Guid) declare in GluonGui.WorkspaceWindow.Views.WorkspaceExplorer.WorkspaceExplorerSettings
bool w_bsS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color) declare in UnityEngine.Handheld
bool w_bsS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color, UnityEngine.FullScreenMovieControlMode) declare in UnityEngine.Handheld
bool w_bsS_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4r4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color, UnityEngine.FullScreenMovieControlMode, UnityEngine.FullScreenMovieScalingMode) declare in UnityEngine.Handheld
bool w_bsS_r4r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_r4r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean op_Equality(System.String, UnityEditor.Search.StringView) declare in UnityEditor.Search.StringView
bool w_bsS_si4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_si4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(apis, env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_si4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ClearCachedVersion(System.String, UnityEngine.Hash128) declare in UnityEngine.Caching
bool w_bsS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, struct S_u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(System.String, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_bsVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len < 1) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if (js_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, js_args_len, 1);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppArray* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetBool(System.String, Boolean) declare in UnityEngine.RemoteSettings
bool w_bsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawSubHeaderFoldout(System.String, Boolean, Boolean) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bsbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, bool p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderFoldout(System.String, Boolean, Boolean, System.Func`1[System.Boolean], System.Action) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bsbDbDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsbDbDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 2);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, bool p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(System.String, Boolean, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_bsbVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsbVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, bool p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetYesOrNoAnswer(System.String, Boolean, Codice.Client.Common.IConsoleReader) declare in Codice.CM.ConfigureHelper.ConfigureHelper
bool w_bsbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsbo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, bool p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Toggle(System.String, Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEditor.EditorGUILayout
bool w_bsboVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsboVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        auto TIp3_V = il2cpp::vm::Class::GetElementClass(TIp3);if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref params
    Il2CppArray* p3 = Params<void*>::PackRef(apis, env, info, TIp3, js_args_len, 3);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, bool p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean EndsWithSeparator(System.String, Char) declare in Codice.Client.Common.PathHelper
bool w_bsc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsc");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsControl(System.String, Int32) declare in System.Char
bool w_bsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryOpenExisting(System.String, System.Security.AccessControl.EventWaitHandleRights, System.Threading.EventWaitHandle ByRef) declare in System.Threading.EventWaitHandle
bool w_bsi4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean PrefetchSocketPolicy(System.String, Int32, Int32) declare in UnityEngine.Security
bool w_bsi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, System.Decimal ByRef) declare in System.Decimal
bool w_bsi4oPS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i4i4i4i4u8_* p3 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4i4i4i4u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i4i4i4i4u8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, struct S_i4i4i4i4u8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, System.Numerics.BigInteger ByRef) declare in System.Numerics.BigInteger
bool w_bsi4oPS_i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPS_i4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i4o_* p3 = DataTransfer::GetPointer<S_i4o_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4o_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i4o_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, struct S_i4o_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, SByte ByRef) declare in System.SByte
bool w_bsi4oPi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int8_t up3 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv3);
    int8_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, int8_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int8_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Int16 ByRef) declare in System.Int16
bool w_bsi4oPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int16_t up3 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv3);
    int16_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, int16_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int16_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Int32 ByRef) declare in System.Int32
bool w_bsi4oPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Int64 ByRef) declare in System.Int64
bool w_bsi4oPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv3);
    int64_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, int64_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int64_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Single ByRef) declare in System.Single
bool w_bsi4oPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, float* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<float>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Double ByRef) declare in System.Double
bool w_bsi4oPr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPr8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    double up3 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv3);
    double* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, double* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<double>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Byte ByRef) declare in System.Byte
bool w_bsi4oPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint8_t up3 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv3);
    uint8_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, uint8_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint8_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, UInt16 ByRef) declare in System.UInt16
bool w_bsi4oPu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint16_t up3 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv3);
    uint16_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, uint16_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint16_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, UInt32 ByRef) declare in System.UInt32
bool w_bsi4oPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, uint32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint32_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, UInt64 ByRef) declare in System.UInt64
bool w_bsi4oPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P primitive
    uint64_t up3 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv3);
    uint64_t* p3 = &up3;

    typedef bool (*FuncToCall)(Il2CppString* p0, int32_t p1, Il2CppObject* p2, uint64_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<uint64_t>::toScript(apis, env, *p3));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ToBoolean(System.String, System.IFormatProvider) declare in System.Convert
bool w_bso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.IFormatProvider, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bsoPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Pstruct
    S_i8_* p2 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i8_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, struct S_i8_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean SaveCursorToFile(System.String, UnityEngine.Texture2D, UnityEngine.Vector2) declare in UnityEditorInternal.InternalEditorUtility
bool w_bsoS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoS_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsUnityWorkspace(System.String, PlasticGui.Help.GuiHelpEvents, System.DateTime) declare in PlasticGui.Help.Conditions.UnityConditions
bool w_bsoS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, struct S_u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Button(System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[]) declare in UnityEngine.GUILayout
bool w_bsoVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        auto TIp2_V = il2cpp::vm::Class::GetElementClass(TIp2);if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2_V, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, js_args_len, 2);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean StaticFlagField(System.String, UnityEditor.SerializedProperty, Int32) declare in UnityEditor.SceneModeUtility
bool w_bsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bsoi4PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p3 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_u8_i2_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_u8_i2_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, struct S_S_u8_i2_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bsoi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal Pstruct
    S_u8_* p3 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_u8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, int32_t p2, struct S_u8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean UnregisterDynamicProperty(System.String, System.ContextBoundObject, System.Runtime.Remoting.Contexts.Context) declare in System.Runtime.Remoting.Contexts.Context
bool w_bsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderToggle(System.String, UnityEditor.SerializedProperty, UnityEditor.SerializedProperty, System.Action`1[UnityEngine.Vector2], System.Func`1[System.Boolean], System.Action) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bsooDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooDoDoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (js_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (js_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 4, TIp4);
                
    // JSValToCSVal ref  with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 5, TIp5);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bsooPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i8_* p3 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, struct S_i8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FilterSelectedOutOfDateItems(System.String, Codice.CM.Common.Update.Partial.OutOfDateItems, Codice.CM.Common.Update.Partial.SelectedItemsCache, Boolean, System.Collections.Generic.List`1[Codice.CM.Common.ErrorMessage], System.StringComparer) declare in Codice.CM.Common.Update.Partial.PartialUpdateFilter
bool w_bsooboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooboo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bsooi4PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p4 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_u8_i2_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_u8_i2_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_S_u8_i2_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bsooi4PS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_i8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_i8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bsooi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_u8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean HasOutOfDateItems(System.String, Codice.CM.Common.RepositorySpec, Codice.CM.Common.Tree.TreeNode, Codice.CM.Common.Tree.TreeNode, Codice.CM.Common.Tree.WorkspaceTreeChangedNode, System.Collections.Generic.List`1[Codice.CM.Common.Partial.FullyCheckedDirectory], Options, System.StringComparison, System.StringComparer) declare in Codice.CM.Common.Update.Partial.OutOfDateCalculator
bool w_bsoooooi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsoooooi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp8 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);

    if (checkJSArgument) {
        if (js_args_len != 9) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv8, TIp8, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
    // JSValToCSVal o/O
    Il2CppObject* p8 = JsValueToCSRef(apis, TIp8, env, _sv8);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, int32_t p7, Il2CppObject* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DrawHeaderToggle(System.String, UnityEditor.SerializedProperty, UnityEditor.SerializedProperty, System.Action`1[UnityEngine.Vector2], System.Func`1[System.Boolean], System.Action, System.String) declare in UnityEditor.Rendering.CoreEditorUtils
bool w_bsooooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsooooos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal o/O
    Il2CppObject* p3 = JsValueToCSRef(apis, TIp3, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal o/O
    Il2CppObject* p5 = JsValueToCSRef(apis, TIp5, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppString* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.String, System.String) declare in System.String
bool w_bss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FuzzyMatch(System.String, System.String, System.Collections.Generic.List`1[System.Int32]) declare in UnityEditor.Search.FuzzySearch
bool w_bssDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (true) {
        if (js_args_len < 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (js_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal ref  with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 2, TIp2);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.String, System.Diagnostics.ActivityContext ByRef) declare in System.Diagnostics.ActivityContext
bool w_bssPS_S_s_S_s_i4sb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssPS_S_s_S_s_i4sb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_S_s_S_s_i4sb_* p2 = DataTransfer::GetPointer<S_S_s_S_s_i4sb_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_s_S_s_i4sb_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_S_s_S_s_i4sb_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, struct S_S_s_S_s_i4sb_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String, System.Guid ByRef) declare in System.Guid
bool w_bssPS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (p2 == &up2)
    {
        apis->update_boxed_value(env, _sv2, DataTransfer::CopyValueType(apis, env, *p2, TIp2));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FuzzyMatch(System.String, System.String, Int64 ByRef, System.Collections.Generic.List`1[System.Int32]) declare in UnityEditor.Search.FuzzySearch
bool w_bssPi8Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssPi8Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (true) {
        if (js_args_len < 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
        if (js_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv2);
    int64_t* p2 = &up2;
    // JSValToCSVal ref  with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, js_args_len, 3, TIp3);
                

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int64_t* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<int64_t>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsValid(System.String, System.String, ValidationResult ByRef) declare in PlasticGui.Configuration.CloudEdition.Welcome.ValidateEmailAndPassword
bool w_bssPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CheckRepositoryExists(System.String, System.String, System.String ByRef) declare in PlasticGui.InputValidator
bool w_bssPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, converter::Converter<Il2CppString*>::toScript(apis, env, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean StringsEqual(System.String, System.String, Boolean) declare in NUnit.Framework.Internal.StringUtil
bool w_bssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParse(System.String, System.String, Boolean, System.Diagnostics.ActivityContext ByRef) declare in System.Diagnostics.ActivityContext
bool w_bssbPS_S_s_S_s_i4sb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssbPS_S_s_S_s_i4sb_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal Pstruct
    S_S_s_S_s_i4sb_* p3 = DataTransfer::GetPointer<S_S_s_S_s_i4sb_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_s_S_s_i4sb_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_S_s_S_s_i4sb_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, struct S_S_s_S_s_i4sb_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Execute(System.String, System.String, Boolean, Boolean) declare in Codice.Client.BaseCommands.ProcessExecutor
bool w_bssbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssbb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, bool p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsSamePath(System.String, System.String, Char) declare in Codice.Client.Common.PathHelper
bool w_bssc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppChar p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.String, System.String, System.StringComparison) declare in System.String
bool w_bssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsMatch(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_bssi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4S_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, int32_t p2, struct S_i8_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ShouldResetDisplayFilters(System.String, System.String, PlasticGui.WorkspaceWindow.Configuration.DisplayFilters) declare in PlasticGui.WorkspaceWindow.QueryViews.QueryViewsOperations
bool w_bsso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bssoPS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssoPS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal Pstruct
    S_i8_* p3 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(S_i8_));
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, struct S_i8_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (p3 == &up3)
    {
        apis->update_boxed_value(env, _sv3, DataTransfer::CopyValueType(apis, env, *p3, TIp3));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef) declare in System.DateTimeOffset
bool w_bssoi4PS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p4 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_u8_i2_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_S_u8_i2_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, struct S_S_u8_i2_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef) declare in System.TimeSpan
bool w_bssoi4PS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_i8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, struct S_i8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bssoi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!apis->is_boxed_value(env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(S_u8_));
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppObject* p2, int32_t p3, struct S_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (p4 == &up4)
    {
        apis->update_boxed_value(env, _sv4, DataTransfer::CopyValueType(apis, env, *p4, TIp4));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean LookupAccountName(System.String, System.String, IntPtr, Int32 ByRef, System.Text.StringBuilder, Int32 ByRef, Codice.CM.SEIDInfo.SID_NAME_USE ByRef) declare in Codice.CM.SEIDInfo.NetWorkAPI
bool w_bsspPi4oPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsspPi4oPi4Pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);

    if (checkJSArgument) {
        if (js_args_len != 7) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!apis->is_boxed_value(env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
        if (!apis->is_boxed_value(env, _sv5)) return false;
        if (!apis->is_boxed_value(env, _sv6)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);
    // JSValToCSVal P primitive
    int32_t up5 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv5);
    int32_t* p5 = &up5;
    // JSValToCSVal P primitive
    int32_t up6 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv6);
    int32_t* p6 = &up6;

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, void* p2, int32_t* p3, Il2CppObject* p4, int32_t* p5, int32_t* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    apis->update_boxed_value(env, _sv3, converter::Converter<int32_t>::toScript(apis, env, *p3));
    apis->update_boxed_value(env, _sv5, converter::Converter<int32_t>::toScript(apis, env, *p5));
    apis->update_boxed_value(env, _sv6, converter::Converter<int32_t>::toScript(apis, env, *p6));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DisplayCancelableProgressBar(System.String, System.String, Single) declare in UnityEditor.EditorUtility
bool w_bssr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DisplayDialog(System.String, System.String, System.String) declare in UnityEditor.EditorUtility
bool w_bsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AddInput(System.String, System.String, System.String, Int32, UnityEngine.ClusterInputType) declare in UnityEngine.ClusterInput
bool w_bsssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsssi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DisplayDialog(System.String, System.String, System.String, UnityEditor.DialogOptOutDecisionType, System.String) declare in UnityEditor.EditorUtility
bool w_bsssi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsssi4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, int32_t p3, Il2CppString* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DisplayDialog(System.String, System.String, System.String, System.String) declare in UnityEditor.EditorUtility
bool w_bssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);

    if (checkJSArgument) {
        if (js_args_len != 4) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Merge(System.String, System.String, System.String, System.String, Codice.CM.Client.Differences.ComparisonMethodTypes) declare in Codice.CM.Client.Differences.Merge.Automatic3WayMerge
bool w_bssssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssssi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean DisplayDialog(System.String, System.String, System.String, System.String, UnityEditor.DialogOptOutDecisionType, System.String) declare in UnityEditor.EditorUtility
bool w_bssssi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssssi4s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);

    if (checkJSArgument) {
        if (js_args_len != 6) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, Il2CppString* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean ShowQuestionWithLearnMore(System.String, System.String, System.String, System.String, Codice.Client.Common.MultiLinkLabelData) declare in Codice.Client.Common.GuiMessage
bool w_bsssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsssso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryProcess(System.String, System.String, System.String, System.String, System.String, System.String, System.String, System.String, System.String, System.String, System.String ByRef) declare in Codice.Client.Common.ClientConfigurationArguments
bool w_bssssssssssPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssssssssssPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];
    auto TIp9 = wrapData->TypeInfos[9];
    auto TIp10 = wrapData->TypeInfos[10];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);
    pesapi_value _sv5 = apis->get_arg(info, 5);
    pesapi_value _sv6 = apis->get_arg(info, 6);
    pesapi_value _sv7 = apis->get_arg(info, 7);
    pesapi_value _sv8 = apis->get_arg(info, 8);
    pesapi_value _sv9 = apis->get_arg(info, 9);
    pesapi_value _sv10 = apis->get_arg(info, 10);

    if (checkJSArgument) {
        if (js_args_len != 11) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv8)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv9)) return false;
        if (!apis->is_boxed_value(env, _sv10)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    // JSValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    // JSValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    // JSValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7);
    // JSValToCSVal s
    Il2CppString* p8 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv8);
    // JSValToCSVal s
    Il2CppString* p9 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv9);
    // JSValToCSVal Ps
    Il2CppString* up10 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv10); // string ref
    Il2CppString** p10 = &up10;
        

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, Il2CppString* p7, Il2CppString* p8, Il2CppString* p9, Il2CppString** p10, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    apis->update_boxed_value(env, _sv10, converter::Converter<Il2CppString*>::toScript(apis, env, *p10));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsValidInput(System.String, System.String, Codice.CM.Common.SEIDWorkingMode, System.String, System.Action`1[System.String]) declare in PlasticGui.Configuration.ValidateServerAndCreds
bool w_bssu1so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bssu1so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);
    pesapi_value _sv3 = apis->get_arg(info, 3);
    pesapi_value _sv4 = apis->get_arg(info, 4);

    if (checkJSArgument) {
        if (js_args_len != 5) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv2)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(apis, env, _sv2);
    // JSValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    // JSValToCSVal o/O
    Il2CppObject* p4 = JsValueToCSRef(apis, TIp4, env, _sv4);

    typedef bool (*FuncToCall)(Il2CppString* p0, Il2CppString* p1, uint8_t p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CanConnectToCacheServer(System.String, UInt16) declare in UnityEditor.AssetDatabase
bool w_bsu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bsu2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0)) return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(Il2CppString* p0, uint16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean get_IsInvalid() declare in Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
bool w_bt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_bt");
    

    int js_args_len = apis->get_args_len(info);
    

    if (checkJSArgument) {
        if (js_args_len != 0) return false;
    }
    

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TrySetCanceled(System.Threading.CancellationToken) declare in Cysharp.Threading.Tasks.AutoResetUniTaskCompletionSource
bool w_btDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btDS_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal valuetype  with default
    S_o_ p0 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef bool (*FuncToCall)(void*,struct S_o_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetBooleanValue(Boolean) declare in UnityEditor.Search.SearchExpression
bool w_btDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btDb");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef bool (*FuncToCall)(void*,bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Import(ImportOptions) declare in UnityEditor.PackageManager.UI.Sample
bool w_btDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btDi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (true) {
        if (js_args_len < 0) return false;
        if (js_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0)) return false;
    }
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, js_args_len, 0);
                

    typedef bool (*FuncToCall)(void*,int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Object) declare in System.String
bool w_btO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Object, System.Object) declare in System.StringComparer
bool w_btOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean AreEqual(System.Object, System.Object, NUnit.Framework.Constraints.Tolerance ByRef) declare in NUnit.Framework.Constraints.NUnitEqualityComparer
bool w_btOOPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOOPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv2)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ref
    Il2CppObject** p2 = &up2;
        

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    apis->update_boxed_value(env, _sv2, CSRefToJsValue(apis, env, TIp2, *p2));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetData(System.Object, System.Object ByRef) declare in Mono.Reflection.MatchContext
bool w_btOPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOPO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetMissingItem(System.Object, Codice.Client.BaseCommands.Merge.Restorer.MissingItemInfo ByRef) declare in Codice.Client.BaseCommands.Merge.Restorer.MountMissingInfo
bool w_btOPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean CanChangeType(System.Object, System.Type, System.Globalization.CultureInfo) declare in System.Reflection.Binder
bool w_btOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Parse(System.Object, System.String) declare in Unity.Plastic.Antlr3.Runtime.Tree.TreeWizard
bool w_btOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Parse(System.Object, System.String, System.Collections.Generic.IDictionary`2[System.String,System.Object]) declare in Unity.Plastic.Antlr3.Runtime.Tree.TreeWizard
bool w_btOso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btOso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal o/O
    Il2CppObject* p0 = JsValueToCSRef(apis, TIp0, env, _sv0);
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(void*,Il2CppObject* p0, Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsKeywordEnabled(UnityEngine.Rendering.LocalKeyword ByRef) declare in UnityEngine.Material
bool w_btPS_S_p_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_p_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_p_su4_* p0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_p_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_p_su4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_S_p_su4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetGroundHit(UnityEngine.WheelHit ByRef) declare in UnityEngine.WheelCollider
bool w_btPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean FindClosestEdge(UnityEngine.AI.NavMeshHit ByRef) declare in UnityEngine.AI.NavMeshAgent
bool w_btPS_S_r4r4r4_S_r4r4r4_r4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_r4r4r4_S_r4r4r4_r4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_r4r4r4_S_r4r4r4_r4i4i4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_r4i4i4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetDateTimeOffset(System.DateTimeOffset ByRef) declare in System.Text.Json.JsonElement
bool w_btPS_S_u8_i2_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_u8_i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_S_u8_i2_* p0 = DataTransfer::GetPointer<S_S_u8_i2_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8_i2_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_S_u8_i2_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_S_u8_i2_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor ByRef, System.Guid, System.Object[]) declare in System.Diagnostics.Eventing.EventProvider
bool w_btPS__S_i4i2i2u1u1u1u1u1u1u1u1_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__S_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S__* p0 = DataTransfer::GetPointer<S__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S__));
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(void*,struct S__* p0, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WriteEvent(System.Diagnostics.Eventing.EventDescriptor ByRef, System.Object[]) declare in System.Diagnostics.Eventing.EventProvider
bool w_btPS__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S__* p0 = DataTransfer::GetPointer<S__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S__));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(void*,struct S__* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean WriteEvent(System.Diagnostics.Eventing.EventDescriptor ByRef, System.String) declare in System.Diagnostics.Eventing.EventProvider
bool w_btPS__s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S__* p0 = DataTransfer::GetPointer<S__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S__));
        p0 = &up0;
    }
        
    // JSValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(void*,struct S__* p0, Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetCullingParameters(UnityEngine.Rendering.ScriptableCullingParameters ByRef) declare in UnityEngine.Camera
bool w_btPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p0 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8S_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetGuid(System.Guid ByRef) declare in System.Xml.UniqueId
bool w_btPS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i2i2u1u1u1u1u1u1u1u1_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetDecimal(System.Decimal ByRef) declare in System.Text.Json.JsonElement
bool w_btPS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_i4i4i4i4u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_i4i4i4i4u8_* p0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4u8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_i4i4i4i4u8_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_i4i4i4i4u8_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Setup(UnityEngine.Rendering.Universal.RenderingData ByRef) declare in UnityEngine.Rendering.Universal.Internal.AdditionalLightsShadowCasterPass
bool w_btPS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p0 = DataTransfer::GetPointer<S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_oS_pPvS_pi4i4__S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_S_r4r4r4r4_bS_r4r4r4r4_S_r4r4r4r4_i4i4r4r4i4i4br4i4bi4bbbbbbbbi4obr4bboS_i4_obbi4i4obS_r4r4r4_S_r4r4r4r4_oS_i4r4r4r4r4r4i4i4_o_S_i4i4i4S_Pvi4i4i4S_pi4i4_i4_bbbbbb_S_bbbi4i4i4S_r4r4r4_r4bbi4i4bi4oobb_S_i4i4bb_bi4b_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetBuffer(System.ArraySegment`1[System.Byte] ByRef) declare in System.IO.MemoryStream
bool w_btPS_oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_oi4i4_* p0 = DataTransfer::GetPointer<S_oi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_oi4i4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_oi4i4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetSerializationContext(JetBrains.Rd.SerializationCtx ByRef) declare in JetBrains.Rd.Base.RdBindableBase
bool w_btPS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_oo_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_oo_* p0 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_oo_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_oo_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetPosition(UnityEngine.Vector3 ByRef) declare in UnityEngine.XR.XRNodeState
bool w_btPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetRotation(UnityEngine.Quaternion ByRef) declare in UnityEngine.XR.XRNodeState
bool w_btPS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsCached(UnityEngine.Vector4 ByRef, Int32) declare in UnityEngine.Rendering.Texture2DAtlas
bool w_btPS_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsCached(UnityEngine.Vector4 ByRef, UnityEngine.Texture) declare in UnityEngine.Rendering.Texture2DAtlas
bool w_btPS_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean IsCached(UnityEngine.Vector4 ByRef, UnityEngine.Texture, UnityEngine.Texture) declare in UnityEngine.Rendering.Texture2DAtlas
bool w_btPS_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);
    pesapi_value _sv2 = apis->get_arg(info, 2);

    if (checkJSArgument) {
        if (js_args_len != 3) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4_));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);
    // JSValToCSVal o/O
    Il2CppObject* p2 = JsValueToCSRef(apis, TIp2, env, _sv2);

    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_* p0, Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetCameraToWorldMatrix(UnityEngine.Matrix4x4 ByRef) declare in UnityEngine.Windows.WebCam.PhotoCaptureFrame
bool w_btPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetHapticCapabilities(UnityEngine.XR.HapticCapabilities ByRef) declare in UnityEngine.XR.InputDevice
bool w_btPS_u4bbu4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u4bbu4u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u4bbu4u4u4_* p0 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4bbu4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u4bbu4u4u4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_u4bbu4u4u4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean OpenAnimationStream(UnityEngine.Animator, UnityEngine.Animations.AnimationStream ByRef) declare in UnityEngine.Animations.AnimatorJobExtensions
bool w_btPS_u4pppppp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u4pppppp_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u4pppppp_* p0 = DataTransfer::GetPointer<S_u4pppppp_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4pppppp_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u4pppppp_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_u4pppppp_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Store(UnityEditor.Search.PropertyDatabaseRecordKey ByRef, System.Object) declare in UnityEditor.Search.PropertyDatabase
bool w_btPS_u8S_u8u8__O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8S_u8u8__O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8S_u8u8__* p0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8S_u8u8__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8S_u8u8__));
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    Il2CppObject* p1 = JsValueToCSRef(apis, TIp1, env, _sv1);

    typedef bool (*FuncToCall)(void*,struct S_u8S_u8u8__* p0, Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryLoad(UnityEditor.Search.PropertyDatabaseRecordKey ByRef, System.Object ByRef) declare in UnityEditor.Search.PropertyDatabase
bool w_btPS_u8S_u8u8__PO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8S_u8u8__PO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8S_u8u8__* p0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8S_u8u8__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8S_u8u8__));
        p0 = &up0;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(void*,struct S_u8S_u8u8__* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryLoad(UnityEditor.Search.PropertyDatabaseRecordKey ByRef, UnityEditor.Search.IPropertyDatabaseRecordValue ByRef) declare in UnityEditor.Search.PropertyDatabase
bool w_btPS_u8S_u8u8__Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8S_u8u8__Po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8S_u8u8__* p0 = DataTransfer::GetPointer<S_u8S_u8u8__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8S_u8u8__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8S_u8u8__));
        p0 = &up0;
    }
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(void*,struct S_u8S_u8u8__* p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
            
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetDateTime(System.DateTime ByRef) declare in System.Text.Json.JsonElement
bool w_btPS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8_* p0 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_u8_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetRootBone(UnityEngine.XR.Bone ByRef) declare in UnityEngine.XR.Hand
bool w_btPS_u8u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Pstruct
    S_u8u4_* p0 = DataTransfer::GetPointer<S_u8u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(S_u8u4_));
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct S_u8u4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (p0 == &up0)
    {
        apis->update_boxed_value(env, _sv0, DataTransfer::CopyValueType(apis, env, *p0, TIp0));
    }
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetSByte(SByte ByRef) declare in System.Text.Json.JsonElement
bool w_btPi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPi1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int8_t up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,int8_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int8_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryReadLittleEndian(System.Buffers.SequenceReader`1[System.Byte] ByRef, Int16 ByRef) declare in System.Buffers.SequenceReaderExtensions
bool w_btPi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPi2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int16_t up0 = converter::Converter<std::reference_wrapper<int16_t>>::toCpp(apis, env, _sv0);
    int16_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,int16_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int16_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryReadLittleEndian(System.Buffers.SequenceReader`1[System.Byte] ByRef, Int32 ByRef) declare in System.Buffers.SequenceReaderExtensions
bool w_btPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,int32_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Remove(Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef) declare in System.ComponentModel.MaskedTextProvider
bool w_btPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPi4Pi4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal P primitive
    int32_t up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef bool (*FuncToCall)(void*,int32_t* p0, int32_t* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int32_t>::toScript(apis, env, *p0));
    apis->update_boxed_value(env, _sv1, converter::Converter<int32_t>::toScript(apis, env, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryReadLittleEndian(System.Buffers.SequenceReader`1[System.Byte] ByRef, Int64 ByRef) declare in System.Buffers.SequenceReaderExtensions
bool w_btPi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPi8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv0);
    int64_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,int64_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<int64_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetLocalNameAsDictionaryString(System.Xml.XmlDictionaryString ByRef) declare in System.Xml.XmlDictionaryReader
bool w_btPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        

    typedef bool (*FuncToCall)(void*,Il2CppObject** p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean GetMethodBounds(Mono.CompilerServices.SymbolWriter.LineNumberEntry ByRef, Mono.CompilerServices.SymbolWriter.LineNumberEntry ByRef) declare in Mono.CompilerServices.SymbolWriter.LineNumberTable
bool w_btPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);
    pesapi_value _sv1 = apis->get_arg(info, 1);

    if (checkJSArgument) {
        if (js_args_len != 2) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
        if (!apis->is_boxed_value(env, _sv1)) return false;
    }
    
    // JSValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ref
    Il2CppObject** p0 = &up0;
        
    // JSValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ref
    Il2CppObject** p1 = &up1;
        

    typedef bool (*FuncToCall)(void*,Il2CppObject** p0, Il2CppObject** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    apis->update_boxed_value(env, _sv0, CSRefToJsValue(apis, env, TIp0, *p0));
    apis->update_boxed_value(env, _sv1, CSRefToJsValue(apis, env, TIp1, *p1));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetLeftEyeOpenAmount(Single ByRef) declare in UnityEngine.XR.Eyes
bool w_btPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPr4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;

    typedef bool (*FuncToCall)(void*,float* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<float>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetDouble(Double ByRef) declare in System.Text.Json.JsonElement
bool w_btPr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPr8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    double up0 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv0);
    double* p0 = &up0;

    typedef bool (*FuncToCall)(void*,double* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<double>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Validate(System.String ByRef) declare in UnityEngine.DetailPrototype
bool w_btPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal Ps
    Il2CppString* up0 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv0); // string ref
    Il2CppString** p0 = &up0;
        

    typedef bool (*FuncToCall)(void*,Il2CppString** p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<Il2CppString*>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetByte(Byte ByRef) declare in System.Text.Json.JsonElement
bool w_btPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPu1");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint8_t up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,uint8_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint8_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetUInt16(UInt16 ByRef) declare in System.Text.Json.JsonElement
bool w_btPu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPu2");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint16_t up0 = converter::Converter<std::reference_wrapper<uint16_t>>::toCpp(apis, env, _sv0);
    uint16_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,uint16_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint16_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetUInt32(UInt32 ByRef) declare in System.Text.Json.JsonElement
bool w_btPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPu4");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint32_t up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,uint32_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint32_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean TryGetUInt64(UInt64 ByRef) declare in System.Text.Json.JsonElement
bool w_btPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btPu8");
    

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!apis->is_boxed_value(env, _sv0)) return false;
    }
    
    // JSValToCSVal P primitive
    uint64_t up0 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv0);
    uint64_t* p0 = &up0;

    typedef bool (*FuncToCall)(void*,uint64_t* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    apis->update_boxed_value(env, _sv0, converter::Converter<uint64_t>::toScript(apis, env, *p0));
    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(Microsoft.Extensions.Primitives.StringValues) declare in Microsoft.Extensions.Primitives.StringValues
bool w_btS_O_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btS_O_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_O_* pp0 = DataTransfer::GetPointer<S_O_>(apis, env, _sv0);
    S_O_ p0 = pp0 ? *pp0 : S_O_ {};

    typedef bool (*FuncToCall)(void*,struct S_O_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Threading.Tasks.ValueTask) declare in System.Threading.Tasks.ValueTask
bool w_btS_Oi2b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Oi2b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi2b_* pp0 = DataTransfer::GetPointer<S_Oi2b_>(apis, env, _sv0);
    S_Oi2b_ p0 = pp0 ? *pp0 : S_Oi2b_ {};

    typedef bool (*FuncToCall)(void*,struct S_Oi2b_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.SequencePosition) declare in System.SequencePosition
bool w_btS_Oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4_* pp0 = DataTransfer::GetPointer<S_Oi4_>(apis, env, _sv0);
    S_Oi4_ p0 = pp0 ? *pp0 : S_Oi4_ {};

    typedef bool (*FuncToCall)(void*,struct S_Oi4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

// Boolean Equals(System.Runtime.InteropServices.ArrayWithOffset) declare in System.Runtime.InteropServices.ArrayWithOffset
bool w_btS_Oi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Oi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    int js_args_len = apis->get_args_len(info);
    
    pesapi_value _sv0 = apis->get_arg(info, 0);

    if (checkJSArgument) {
        if (js_args_len != 1) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true)) return false;
    }
    
    // JSValToCSVal struct
    S_Oi4i4_* pp0 = DataTransfer::GetPointer<S_Oi4i4_>(apis, env, _sv0);
    S_Oi4i4_ p0 = pp0 ? *pp0 : S_Oi4i4_ {};

    typedef bool (*FuncToCall)(void*,struct S_Oi4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    apis->add_return(info, converter::Converter<bool>::toScript(apis, env, ret));
    return true;
}

}

